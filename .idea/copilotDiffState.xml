<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/headers/client_logic.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/headers/client_logic.h" />
              <option name="originalContent" value="//&#10;// Created by damko on 23/12/2025.&#10;//&#10;&#10;#ifndef SEMESTRALKA_CLIENT_LOGIC_H&#10;#define SEMESTRALKA_CLIENT_LOGIC_H&#10;&#10;/**&#10; * @file client_logic.h&#10; * @brief Deklarácie klientských funkcií a typov pre vizualizáciu simulácie.&#10; *&#10; * Tento header poskytuje prototypy funkcií používaných na zobrazenie výsledkov&#10; * simulácie a spracovanie lokálnych vstupov (klávesnica). Obsahuje tiež jednoduchý&#10; * enum a štruktúru pre lokálne režimy zobrazenia a odovzdávanie argumentov vlákna.&#10; */&#10;&#10;#include &quot;ipc_shm.h&quot;&#10;&#10;&#10;&#10;// Definícia režimov zobrazenia - len pre potreby klienta&#10;/**&#10; * @brief Režimy, v ktorých môže klient zobrazovať sumárne výsledky.&#10; *&#10; * ZOBRAZ_PRIEMER_KROKOV: zobrazenie priemerného počtu krokov.&#10; * ZOBRAZ_PRAVDEPODOBNOST_K: zobrazenie percentuálnej úspešnosti dosiahnutia cieľa.&#10; */&#10;typedef enum {&#10;    ZOBRAZ_PRIEMER_KROKOV,&#10;    ZOBRAZ_PRAVDEPODOBNOST_K&#10;} RezimZobrazenia_t;&#10;&#10;// Štruktúra pre vlákno, aby som mu odovzdal SHM aj lokálne nastavenie&#10;/**&#10; * @brief Argumenty pre vlákno spracúvajúce klávesnicu.&#10; *&#10; * Obsahuje ukazovateľ na zdieľanú pamäť `shm` a ukazovateľ na lokálny&#10; * režim zobrazenia `p_rezim`, ktorý môže vlákno meniť (lokálne pre klienta).&#10; */&#10;typedef struct {&#10;    ZdielaneData_t* shm;&#10;    RezimZobrazenia_t* p_rezim;&#10;} VlaknoArgs_t;&#10;&#10;/**&#10; * @brief Hlavná funkcia klienta, ktorá riadi prijímanie signálov a vykresľovanie.&#10; *&#10; * Spúšťa vlákno na čítanie klávesnice, čaká na semafór `data_ready` a volá&#10; * vykresľovacie funkcie podľa aktuálneho módu v `shm`.&#10; */&#10;void spusti_klienta(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Vláknová funkcia, ktorá beží na pozadí a spracúva stlačenia kláves.&#10; *&#10; * Očakáva argument typu `VlaknoArgs_t*`.&#10; */&#10;void* kontrola_klavestnice(void* arg);&#10;&#10;/**&#10; * @brief Vykreslí mapu sveta s aktuálnou pozíciou chodca (znak 'C').&#10; *&#10; * Používa `shm-&gt;aktualna_pozicia_chodca` a `shm-&gt;svet` na zostavenie ASCII mapy.&#10; */&#10;void vykresli_mriezku_s_chodcom(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Vykreslí finálnu tabuľku so štatistikami (priemerné kroky a percentá).&#10; *&#10; * Režim zobrazenia určuje parameter `rezim`.&#10; */&#10;void vykresli_tabulku_statistik(ZdielaneData_t* shm, RezimZobrazenia_t rezim);&#10;&#10;/**&#10; * @brief Vypíše ovládacie prvky (legendu) a stručný stav simulácie.&#10; *&#10; * Zobrazí nápovedu pre používateľa (klávesové skratky) a aktuálny stav.&#10; */&#10;void vykresli_legendu(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Prepne lokálny režim zobrazenia (priemer &lt;-&gt; pravdepodobnosť).&#10; *&#10; * Táto funkcia mení len lokálny režim `*p_rezim` a neovplyvňuje zdieľanú pamäť.&#10; * @param klavesa Stlačená klávesa (očakáva 'v' alebo 'V').&#10; * @param p_rezim Ukazovateľ na lokálny režim zobrazenia.&#10; */&#10;void prepni_lokalny_rezim_zobrazenia(int klavesa, RezimZobrazenia_t* p_rezim);&#10;&#10;/**&#10; * @brief Koordinuje, čo sa má vykresliť podľa aktuálneho módu simulácie.&#10; *&#10; * Volá `vykresli_mriezku_s_chodcom` v interaktívnom móde alebo&#10; * `vykresli_tabulku_statistik` v sumárnom móde a nakoniec vypíše legendu.&#10; */&#10;void obsluz_vykreslovanie(ZdielaneData_t* shm, RezimZobrazenia_t rezim);&#10;&#10;#endif // SEMESTRALKA_CLIENT_LOGIC_H&#10;" />
              <option name="updatedContent" value="//&#10;// Created by damko on 23/12/2025.&#10;//&#10;&#10;#ifndef SEMESTRALKA_CLIENT_LOGIC_H&#10;#define SEMESTRALKA_CLIENT_LOGIC_H&#10;&#10;/**&#10; * @file client_logic.h&#10; * @brief Deklarácie klientských funkcií a typov pre vizualizáciu simulácie.&#10; *&#10; * Tento header poskytuje prototypy funkcií používaných na zobrazenie výsledkov&#10; * simulácie a spracovanie lokálnych vstupov (klávesnica). Obsahuje tiež jednoduchý&#10; * enum a štruktúru pre lokálne režimy zobrazenia a odovzdávanie argumentov vlákna.&#10; */&#10;&#10;#include &quot;ipc_shm.h&quot;&#10;&#10;&#10;&#10;// Definícia režimov zobrazenia - len pre potreby klienta&#10;/**&#10; * @brief Režimy, v ktorých môže klient zobrazovať sumárne výsledky.&#10; *&#10; * ZOBRAZ_PRIEMER_KROKOV: zobrazenie priemerného počtu krokov.&#10; * ZOBRAZ_PRAVDEPODOBNOST_K: zobrazenie percentuálnej úspešnosti dosiahnutia cieľa.&#10; */&#10;typedef enum {&#10;    ZOBRAZ_PRIEMER_KROKOV,&#10;    ZOBRAZ_PRAVDEPODOBNOST_K&#10;} RezimZobrazenia_t;&#10;&#10;// Štruktúra pre vlákno, aby som mu odovzdal SHM aj lokálne nastavenie&#10;/**&#10; * @brief Argumenty pre vlákno spracúvajúce klávesnicu.&#10; *&#10; * Obsahuje ukazovateľ na zdieľanú pamäť `shm` a ukazovateľ na lokálny&#10; * režim zobrazenia `p_rezim`, ktorý môže vlákno meniť (lokálne pre klienta).&#10; */&#10;typedef struct {&#10;    ZdielaneData_t* shm;&#10;    RezimZobrazenia_t* p_rezim;&#10;} VlaknoArgs_t;&#10;&#10;/**&#10; * @brief Hlavná funkcia klienta, ktorá riadi prijímanie signálov a vykresľovanie.&#10; *&#10; * Spúšťa vlákno na čítanie klávesnice, čaká na semafór `data_ready` a volá&#10; * vykresľovacie funkcie podľa aktuálneho módu v `shm`.&#10; */&#10;void spusti_klienta(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Vláknová funkcia, ktorá beží na pozadí a spracúva stlačenia kláves.&#10; *&#10; * Očakáva argument typu `VlaknoArgs_t*`.&#10; */&#10;void* kontrola_klavestnice(void* arg);&#10;&#10;/**&#10; * @brief Vykreslí mapu sveta s aktuálnou pozíciou chodca (znak 'C').&#10; *&#10; * Používa `shm-&gt;aktualna_pozicia_chodca` a `shm-&gt;svet` na zostavenie ASCII mapy.&#10; */&#10;void vykresli_mriezku_s_chodcom(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Vykreslí finálnu tabuľku so štatistikami (priemerné kroky a percentá).&#10; *&#10; * Režim zobrazenia určuje parameter `rezim`.&#10; */&#10;void vykresli_tabulku_statistik(ZdielaneData_t* shm, RezimZobrazenia_t rezim);&#10;&#10;/**&#10; * @brief Vypíše ovládacie prvky (legendu) a stručný stav simulácie.&#10; *&#10; * Zobrazí nápovedu pre používateľa (klávesové skratky) a aktuálny stav.&#10; */&#10;void vykresli_legendu(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Prepne lokálny režim zobrazenia (priemer &lt;-&gt; pravdepodobnosť).&#10; *&#10; * Táto funkcia mení len lokálny režim `*p_rezim` a neovplyvňuje zdieľanú pamäť.&#10; * @param klavesa Stlačená klávesa (očakáva 'v' alebo 'V').&#10; * @param p_rezim Ukazovateľ na lokálny režim zobrazenia.&#10; */&#10;void prepni_lokalny_rezim_zobrazenia(int klavesa, RezimZobrazenia_t* p_rezim);&#10;&#10;/**&#10; * @brief Koordinuje, čo sa má vykresliť podľa aktuálneho módu simulácie.&#10; *&#10; * Volá `vykresli_mriezku_s_chodcom` v interaktívnom móde alebo&#10; * `vykresli_tabulku_statistik` v sumárnom móde a nakoniec vypíše legendu.&#10; */&#10;void obsluz_vykreslovanie(ZdielaneData_t* shm, RezimZobrazenia_t rezim);&#10;&#10;#endif // SEMESTRALKA_CLIENT_LOGIC_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/headers/client_menu.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/headers/client_menu.h" />
              <option name="originalContent" value="//&#10;// Created by damko on 16/12/2025.&#10;//&#10;&#10;#ifndef SEMESTRALKA_CLIENT_MENU_H&#10;#define SEMESTRALKA_CLIENT_MENU_H&#10;&#10;/**&#10; * @file client_menu.h&#10; * @brief Rozhranie pre funkcie zobrazujúce menu a načítanie vstupu od používateľa.&#10; *&#10; * Obsahuje prototypy funkcií, ktoré načítavajú parametre simulácie z konzoly&#10; * (bezpečné čítanie celých čísel, názvov súborov, a smerových pravdepodobností)&#10; * a funkciu pre zobrazenie počiatočného menu.&#10; */&#10;&#10;#include &quot;ipc_shm.h&quot;&#10;&#10;/**&#10; * @brief Zobrazí počiatočné menu a načíta nastavenia simulácie od používateľa.&#10; *&#10; * Funkcia obsluhuje výber medzi novou náhodnou simuláciou a opätovným spustením&#10; * zo súboru. Podľa zvoleného módu vyzve používateľa na relevantné parametre&#10; * (počet replikácií, kroky, hustota prekážok, rozmery mapy, pravdepodobnosti).&#10; * Výsledok uloží do zdieľanej pamäte `shm` a nastaví `shm-&gt;stav = SIM_INIT`.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť, kam sa uložia zvolené nastavenia.&#10; */&#10;void zobraz_pociatocne_menu(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Bezpečne načíta celé číslo z konzoly v zadanom rozsahu.&#10; *&#10; * Funkcia opakuje výzvu kým používateľ nezadá platné celé číslo v intervale&#10; * [min, max]. Pri neplatnom vstupe vyprázdni vstupný buffer a vypíše chybovú správu.&#10; *&#10; * @param otazka Text výzvy, ktorý sa vypíše používateľovi.&#10; * @param min Minimálna povolená hodnota (vrátane).&#10; * @param max Maximálna povolená hodnota (vrátane).&#10; * @return Načítaná celočíselná hodnota v rozsahu [min, max].&#10; */&#10;int nacitaj_cele_cislo(const char* otazka, int min, int max);&#10;&#10;/**&#10; * @brief Načíta názov súboru od používateľa s kontrolou prípony &quot;.txt&quot;.&#10; *&#10; * Opakuje výzvu až kým používateľ nezadá reťazec končiaci na &quot;.txt&quot;.&#10; * Výsledný názov je uložený do bufferu `kam_ulozit` (max 255 znakov).&#10; *&#10; * @param kam_ulozit Buffer kam sa uloží zadaný názov súboru (min veľkosť 256).&#10; * @param text_vyzvy Text výzvy, ktorý sa vypíše používateľovi.&#10; */&#10;void nacitaj_nazov_suboru(char* kam_ulozit, const char* text_vyzvy);&#10;&#10;/**&#10; * @brief Načíta a validuje štyri smerové pravdepodobnosti z konzoly.&#10; *&#10; * Požiada používateľa o pravdepodobnosti pre smery &quot;Hore&quot;, &quot;Dole&quot;, &quot;Vlavo&quot;, &quot;Vpravo&quot;.&#10; * Hodnoty sa zadávajú ako desatinné čísla s bodkou (napr. 0.25). Funkcia zabezpečí,&#10; * že každá hodnota je v intervale [0.0, 1.0] a že súčet všetkých štyroch hodnôt je&#10; * približne 1.0 (povolená odchýlka 0.001). Hodnoty sa ukladajú priamo do `shm-&gt;pravdepodobnost`.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť, kde sú pravdepodobnosti uložené.&#10; */&#10;void nacitaj_pravdepodobnosti(ZdielaneData_t* shm);&#10;&#10;#endif //SEMESTRALKA_CLIENT_MENU_H" />
              <option name="updatedContent" value="//&#10;// Created by damko on 16/12/2025.&#10;//&#10;&#10;#ifndef SEMESTRALKA_CLIENT_MENU_H&#10;#define SEMESTRALKA_CLIENT_MENU_H&#10;&#10;/**&#10; * @file client_menu.h&#10; * @brief Rozhranie pre funkcie zobrazujúce menu a načítanie vstupu od používateľa.&#10; *&#10; * Obsahuje prototypy funkcií, ktoré načítavajú parametre simulácie z konzoly&#10; * (bezpečné čítanie celých čísel, názvov súborov, a smerových pravdepodobností)&#10; * a funkciu pre zobrazenie počiatočného menu.&#10; */&#10;&#10;#include &quot;ipc_shm.h&quot;&#10;&#10;/**&#10; * @brief Zobrazí počiatočné menu a načíta nastavenia simulácie od používateľa.&#10; *&#10; * Funkcia obsluhuje výber medzi novou náhodnou simuláciou a opätovným spustením&#10; * zo súboru. Podľa zvoleného módu vyzve používateľa na relevantné parametre&#10; * (počet replikácií, kroky, hustota prekážok, rozmery mapy, pravdepodobnosti).&#10; * Výsledok uloží do zdieľanej pamäte `shm` a nastaví `shm-&gt;stav = SIM_INIT`.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť, kam sa uložia zvolené nastavenia.&#10; */&#10;void zobraz_pociatocne_menu(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Bezpečne načíta celé číslo z konzoly v zadanom rozsahu.&#10; *&#10; * Funkcia opakuje výzvu kým používateľ nezadá platné celé číslo v intervale&#10; * [min, max]. Pri neplatnom vstupe vyprázdni vstupný buffer a vypíše chybovú správu.&#10; *&#10; * @param otazka Text výzvy, ktorý sa vypíše používateľovi.&#10; * @param min Minimálna povolená hodnota (vrátane).&#10; * @param max Maximálna povolená hodnota (vrátane).&#10; * @return Načítaná celočíselná hodnota v rozsahu [min, max].&#10; */&#10;int nacitaj_cele_cislo(const char* otazka, int min, int max);&#10;&#10;/**&#10; * @brief Načíta názov súboru od používateľa s kontrolou prípony &quot;.txt&quot;.&#10; *&#10; * Opakuje výzvu až kým používateľ nezadá reťazec končiaci na &quot;.txt&quot;.&#10; * Výsledný názov je uložený do bufferu `kam_ulozit` (max 255 znakov).&#10; *&#10; * @param kam_ulozit Buffer kam sa uloží zadaný názov súboru (min veľkosť 256).&#10; * @param text_vyzvy Text výzvy, ktorý sa vypíše používateľovi.&#10; */&#10;void nacitaj_nazov_suboru(char* kam_ulozit, const char* text_vyzvy);&#10;&#10;/**&#10; * @brief Načíta a validuje štyri smerové pravdepodobnosti z konzoly.&#10; *&#10; * Požiada používateľa o pravdepodobnosti pre smery &quot;Hore&quot;, &quot;Dole&quot;, &quot;Vlavo&quot;, &quot;Vpravo&quot;.&#10; * Hodnoty sa zadávajú ako desatinné čísla s bodkou (napr. 0.25). Funkcia zabezpečí,&#10; * že každá hodnota je v intervale [0.0, 1.0] a že súčet všetkých štyroch hodnôt je&#10; * približne 1.0 (povolená odchýlka 0.001). Hodnoty sa ukladajú priamo do `shm-&gt;pravdepodobnost`.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť, kde sú pravdepodobnosti uložené.&#10; */&#10;void nacitaj_pravdepodobnosti(ZdielaneData_t* shm);&#10;&#10;#endif //SEMESTRALKA_CLIENT_MENU_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/headers/ipc_shm.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/headers/ipc_shm.h" />
              <option name="originalContent" value="//struktura pre zdielanu pamat&#10;&#10;#ifndef IPC_H&#10;#define IPC_H&#10;&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &lt;sys/types.h&gt;&#10;#include &lt;sys/ipc.h&gt;&#10;&#10;#include &quot;common.h&quot;&#10;&#10;/**&#10; * @brief Režim simulácie (interaktívny alebo sumárny).&#10; */&#10;typedef enum {&#10;    INTERAKTIVNY = 0,&#10;    SUMARNY = 1&#10;}SimulaciaMod_t;&#10;&#10;/**&#10; * @brief Výsledky pre jedno políčko v mriežke.&#10; *&#10; * Uchováva kumulatívny súčet krokov (pre výpočet priemerov), počítadlo úspechov&#10; * a príznak, či bolo políčko navštívené pri BFS validácii sveta.&#10; */&#10;typedef struct {&#10;    double avg_kroky; //avg pocet krokov na dosiahnutie [0,0]&#10;    double pravdepodobnost_dosiahnutia; //pravdepodobnost dosiahnutia [0,0] po max K(krokoch)&#10;    bool navstivene; //zistuje ci je policko dosiahnutelne/navstivene(pre generovanie prekazok)&#10;}Policko_vysledok;&#10;&#10;/**&#10; * @brief Hlavná dátová štruktúra zdieľanej pamäte medzi serverom a klientom.&#10; *&#10; * Obsahuje semafory, nastavenia simulácie, stav, mapu sveta, výsledky, súborové&#10; * nastavenia a riadiace príznaky.&#10; */&#10;typedef struct {&#10;    //synch prostriedky&#10;    sem_t shm_mutex; //binarny semafor na ochranu pred subeznym zapisom/citanim&#10;    sem_t data_ready; //Semafor: server signalizuje ze su nove data pre klienta&#10;&#10;    //nastavenia (definovane klientom na zaciatko)&#10;    int riadky;&#10;    int stlpece;&#10;    int K_max_kroky;&#10;    int total_replikacie;&#10;    int pocet_prekazok;&#10;    double pravdepodobnost[4]; //Pravdepodobnost pobyhu (hore, dole, vlavo, vpravo)&#10;&#10;    //stav simulacie (aktualizovane serverom)&#10;    volatile Simulacia_stav stav; //aktualny stav simulacie (INIT...)&#10;    int aktualne_replikacie; //cislo replikacie&#10;&#10;    SimulaciaMod_t mod;&#10;&#10;    //data sveta a vysledky&#10;    Typ_policka svet[MAX_ROWS][MAX_COLS];&#10;    Policko_vysledok vysledky[MAX_ROWS][MAX_COLS];&#10;    Pozicia_t aktualna_pozicia_chodca; //aktualna pozicia chodca&#10;&#10;    //riadenie a ukoncenie&#10;    bool client_ukoncenie; //ak klient zatvori aplikaciu (server sa tiez ma ukoncit)&#10;&#10;    //praca zo suborom&#10;    char nazov_suboru[256];&#10;    bool opetovne_spustenie; //prikaz ze idem citat zo suboru&#10;}ZdielaneData_t;&#10;&#10;/**&#10; * @brief Vytvorí (ak treba) a pripojí segment zdieľanej pamäte.&#10; *&#10; * Alokuje segment SHM a inicializuje semafory a vráti ukazovateľ na pamäť.&#10; * @param key Kľúč pre segment.&#10; * @return Ukazovateľ na alokovanú a pripojenú `ZdielaneData_t` alebo NULL pri chybe.&#10; */&#10;ZdielaneData_t* shm_create_and_attach(key_t key); // Vracia pointer, pretože SHM alokuje pamäť dynamicky&#10;&#10;/**&#10; * @brief Odpojí a odstráni segment zdieľanej pamäte (ak existuje).&#10; *&#10; * Odpojí lokálne pripojenie a pokúsi sa označiť segment pre odstránenie.&#10; */&#10;void shm_detach_and_destroy(ZdielaneData_t* shm_ptr, key_t key);&#10;&#10;/**&#10; * @brief Zničí semafory, ktoré boli inicializované v `shm_create_and_attach`.&#10; */&#10;void shm_cleanup_semaphores(ZdielaneData_t* shm_ptr);&#10;&#10;#endif //IPC_H" />
              <option name="updatedContent" value="//struktura pre zdielanu pamat&#13;&#10;&#13;&#10;#ifndef IPC_H&#13;&#10;#define IPC_H&#13;&#10;&#13;&#10;#include &lt;semaphore.h&gt;&#13;&#10;#include &lt;stdbool.h&gt;&#13;&#10;#include &lt;sys/types.h&gt;&#13;&#10;#include &lt;sys/ipc.h&gt;&#13;&#10;&#13;&#10;#include &quot;common.h&quot;&#13;&#10;&#13;&#10;/**&#13;&#10; * @brief Režim simulácie (interaktívny alebo sumárny).&#13;&#10; */&#13;&#10;typedef enum {&#13;&#10;    INTERAKTIVNY = 0,&#13;&#10;    SUMARNY = 1&#13;&#10;}SimulaciaMod_t;&#13;&#10;&#13;&#10;/**&#13;&#10; * @brief Výsledky pre jedno políčko v mriežke.&#13;&#10; *&#13;&#10; * Uchováva kumulatívny súčet krokov (pre výpočet priemerov), počítadlo úspechov&#13;&#10; * a príznak, či bolo políčko navštívené pri BFS validácii sveta.&#13;&#10; */&#13;&#10;typedef struct {&#13;&#10;    double avg_kroky; //avg pocet krokov na dosiahnutie [0,0]&#13;&#10;    double pravdepodobnost_dosiahnutia; //pravdepodobnost dosiahnutia [0,0] po max K(krokoch)&#13;&#10;    bool navstivene; //zistuje ci je policko dosiahnutelne/navstivene(pre generovanie prekazok)&#13;&#10;}Policko_vysledok;&#13;&#10;&#13;&#10;/**&#13;&#10; * @brief Hlavná dátová štruktúra zdieľanej pamäte medzi serverom a klientom.&#13;&#10; *&#13;&#10; * Obsahuje semafory, nastavenia simulácie, stav, mapu sveta, výsledky, súborové&#13;&#10; * nastavenia a riadiace príznaky.&#13;&#10; */&#13;&#10;typedef struct {&#13;&#10;    //synch prostriedky&#13;&#10;    sem_t shm_mutex; //binarny semafor na ochranu pred subeznym zapisom/citanim&#13;&#10;    sem_t data_ready; //Semafor: server signalizuje ze su nove data pre klienta&#13;&#10;&#13;&#10;    //nastavenia (definovane klientom na zaciatko)&#13;&#10;    int riadky;&#13;&#10;    int stlpece;&#13;&#10;    int K_max_kroky;&#13;&#10;    int total_replikacie;&#13;&#10;    int pocet_prekazok;&#13;&#10;    double pravdepodobnost[4]; //Pravdepodobnost pobyhu (hore, dole, vlavo, vpravo)&#13;&#10;&#13;&#10;    //stav simulacie (aktualizovane serverom)&#13;&#10;    volatile Simulacia_stav stav; //aktualny stav simulacie (INIT...)&#13;&#10;    int aktualne_replikacie; //cislo replikacie&#13;&#10;&#13;&#10;    SimulaciaMod_t mod;&#13;&#10;&#13;&#10;    //data sveta a vysledky&#13;&#10;    Typ_policka svet[MAX_ROWS][MAX_COLS];&#13;&#10;    Policko_vysledok vysledky[MAX_ROWS][MAX_COLS];&#13;&#10;    Pozicia_t aktualna_pozicia_chodca; //aktualna pozicia chodca&#13;&#10;&#13;&#10;    //riadenie a ukoncenie&#13;&#10;    bool client_ukoncenie; //ak klient zatvori aplikaciu (server sa tiez ma ukoncit)&#13;&#10;&#13;&#10;    //praca zo suborom&#13;&#10;    char nazov_suboru[256];&#13;&#10;    bool opetovne_spustenie; //prikaz ze idem citat zo suboru&#13;&#10;}ZdielaneData_t;&#13;&#10;&#13;&#10;/**&#13;&#10; * @brief Vytvorí (ak treba) a pripojí segment zdieľanej pamäte.&#13;&#10; *&#13;&#10; * Alokuje segment SHM a inicializuje semafory a vráti ukazovateľ na pamäť.&#13;&#10; * @param key Kľúč pre segment.&#13;&#10; * @return Ukazovateľ na alokovanú a pripojenú `ZdielaneData_t` alebo NULL pri chybe.&#13;&#10; */&#13;&#10;ZdielaneData_t* shm_create_and_attach(key_t key); // Vracia pointer, pretože SHM alokuje pamäť dynamicky&#13;&#10;&#13;&#10;/**&#13;&#10; * @brief Odpojí a odstráni segment zdieľanej pamäte (ak existuje).&#13;&#10; *&#13;&#10; * Odpojí lokálne pripojenie a pokúsi sa označiť segment pre odstránenie.&#13;&#10; */&#13;&#10;void shm_detach_and_destroy(ZdielaneData_t* shm_ptr, key_t key);&#13;&#10;&#13;&#10;/**&#13;&#10; * @brief Zničí semafory, ktoré boli inicializované v `shm_create_and_attach`.&#13;&#10; */&#13;&#10;void shm_cleanup_semaphores(ZdielaneData_t* shm_ptr);&#13;&#10;&#13;&#10;#endif //IPC_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/headers/server_logic.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/headers/server_logic.h" />
              <option name="originalContent" value="//&#10;// Created by damko on 16/12/2025.&#10;//&#10;&#10;#ifndef SEMESTRALKA_SERVER_LOGIC_H&#10;#define SEMESTRALKA_SERVER_LOGIC_H&#10;&#10;/**&#10; * @file server_logic.h&#10; * @brief Deklarácie funkcií riadiacich logiku servera simulácie chôdze.&#10; *&#10; * Tento header obsahuje prototypy funkcií implementovaných v `server.c`.&#10; * Funkcie zahŕňajú inicializáciu sveta, generovanie prekážok, samotnú&#10; * simuláciu jedného chodca, vykonanie sumárnej simulácie pre všetky políčka&#10; * a ukladanie/načítanie konfigurácie a výsledkov zo súboru.&#10; */&#10;&#10;#include &quot;common.h&quot;&#10;#include &quot;ipc_shm.h&quot;&#10;&#10;/**&#10; * @brief Spustí hlavnú riadiacu slučku servera (čakanie na klienta, spustenie simulácie).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť obsahujúcu konfiguráciu a výsledky.&#10; */&#10;void spusti_server(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Uloží výsledky simulácie a konfiguráciu sveta do súboru.&#10; *&#10; * Ukladá rozmery, počet replikácií, maximálny počet krokov, počet prekážok,&#10; * pravdepodobnosti pohybov, mapu sveta a agregované výsledky pre každé políčko.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; */&#10;void uloz_vysledky_do_suboru(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Načíta konfiguráciu a mapu sveta zo súboru do zdieľanej pamäte.&#10; *&#10; * Očakáva formát uložený funkciou `uloz_vysledky_do_suboru`.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru, kde sa načítané hodnoty uložia.&#10; * @return true ak bolo načítanie úspešné, inak false.&#10; */&#10;bool nacitaj_konfig_zo_suboru(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Overí, či je svet priechodný (všetky neprekážkové políčka dosiahnuteľné z [0,0]).&#10; *&#10; * Používa BFS na toroidnej mriežke.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu mapu a rozmery.&#10; * @return true ak sú všetky neprekážkové políčka dosiahnuteľné, inak false.&#10; */&#10;bool je_svet_validny(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Vygeneruje náhodný svet s prekážkami podľa percenta.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; * @param percento_prekazok Celé percento (0-100) šance, že políčko bude prekážka.&#10; */&#10;void generuj_svet_s_prekazkami(ZdielaneData_t* shm, int percento_prekazok);&#10;&#10;/**&#10; * @brief Vyberie smer pohybu na základe nastavených pravdepodobností.&#10; *&#10; * Indexy: 0 = HORE, 1 = DOLE, 2 = VLAVO, 3 = VPRAVO.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu pole pravdepodobností.&#10; * @return Číslo v rozsahu 0..3 reprezentujúce smer.&#10; */&#10;int vyber_smeru(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Simuluje jedného chodca z daného štartovacieho políčka.&#10; *&#10; * Po skončení replikácie aktualizuje štatistiky (priemerné kroky a počet úspechov)&#10; * pre štartovacie políčko.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; * @param start_r Počiatočný riadok chodca.&#10; * @param start_s Počiatočný stĺpec chodca.&#10; */&#10;void simuluj_chodzu_z_policka(ZdielaneData_t* shm, int start_r, int start_s);&#10;&#10;/**&#10; * @brief Inicializuje herný svet pre server (načíta zo súboru alebo vygeneruje nový).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; * @return true ak bol svet úspešne inicializovaný, false pri chybe alebo stop požiadavke.&#10; */&#10;bool inicializuj_svet_servera(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Vykoná kompletnú sumárnu simuláciu pre všetky políčka sveta.&#10; *&#10; * Pre každú replikáciu prejde všetky políčka a spustí z neho simuláciu chôdze ak nie je prekážka.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; */&#10;void vykonaj_sumarnu_simulaciu(ZdielaneData_t* shm);&#10;&#10;#endif" />
              <option name="updatedContent" value="//&#10;// Created by damko on 16/12/2025.&#10;//&#10;&#10;#ifndef SEMESTRALKA_SERVER_LOGIC_H&#10;#define SEMESTRALKA_SERVER_LOGIC_H&#10;&#10;/**&#10; * @file server_logic.h&#10; * @brief Deklarácie funkcií riadiacich logiku servera simulácie chôdze.&#10; *&#10; * Tento header obsahuje prototypy funkcií implementovaných v `server.c`.&#10; * Funkcie zahŕňajú inicializáciu sveta, generovanie prekážok, samotnú&#10; * simuláciu jedného chodca, vykonanie sumárnej simulácie pre všetky políčka&#10; * a ukladanie/načítanie konfigurácie a výsledkov zo súboru.&#10; */&#10;&#10;#include &quot;common.h&quot;&#10;#include &quot;ipc_shm.h&quot;&#10;&#10;/**&#10; * @brief Spustí hlavnú riadiacu slučku servera (čakanie na klienta, spustenie simulácie).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť obsahujúcu konfiguráciu a výsledky.&#10; */&#10;void spusti_server(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Uloží výsledky simulácie a konfiguráciu sveta do súboru.&#10; *&#10; * Ukladá rozmery, počet replikácií, maximálny počet krokov, počet prekážok,&#10; * pravdepodobnosti pohybov, mapu sveta a agregované výsledky pre každé políčko.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; */&#10;void uloz_vysledky_do_suboru(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Načíta konfiguráciu a mapu sveta zo súboru do zdieľanej pamäte.&#10; *&#10; * Očakáva formát uložený funkciou `uloz_vysledky_do_suboru`.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru, kde sa načítané hodnoty uložia.&#10; * @return true ak bolo načítanie úspešné, inak false.&#10; */&#10;bool nacitaj_konfig_zo_suboru(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Overí, či je svet priechodný (všetky neprekážkové políčka dosiahnuteľné z [0,0]).&#10; *&#10; * Používa BFS na toroidnej mriežke.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu mapu a rozmery.&#10; * @return true ak sú všetky neprekážkové políčka dosiahnuteľné, inak false.&#10; */&#10;bool je_svet_validny(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Vygeneruje náhodný svet s prekážkami podľa percenta.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; * @param percento_prekazok Celé percento (0-100) šance, že políčko bude prekážka.&#10; */&#10;void generuj_svet_s_prekazkami(ZdielaneData_t* shm, int percento_prekazok);&#10;&#10;/**&#10; * @brief Vyberie smer pohybu na základe nastavených pravdepodobností.&#10; *&#10; * Indexy: 0 = HORE, 1 = DOLE, 2 = VLAVO, 3 = VPRAVO.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu pole pravdepodobností.&#10; * @return Číslo v rozsahu 0..3 reprezentujúce smer.&#10; */&#10;int vyber_smeru(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Simuluje jedného chodca z daného štartovacieho políčka.&#10; *&#10; * Po skončení replikácie aktualizuje štatistiky (priemerné kroky a počet úspechov)&#10; * pre štartovacie políčko.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; * @param start_r Počiatočný riadok chodca.&#10; * @param start_s Počiatočný stĺpec chodca.&#10; */&#10;void simuluj_chodzu_z_policka(ZdielaneData_t* shm, int start_r, int start_s);&#10;&#10;/**&#10; * @brief Inicializuje herný svet pre server (načíta zo súboru alebo vygeneruje nový).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; * @return true ak bol svet úspešne inicializovaný, false pri chybe alebo stop požiadavke.&#10; */&#10;bool inicializuj_svet_servera(ZdielaneData_t* shm);&#10;&#10;/**&#10; * @brief Vykoná kompletnú sumárnu simuláciu pre všetky políčka sveta.&#10; *&#10; * Pre každú replikáciu prejde všetky políčka a spustí z neho simuláciu chôdze ak nie je prekážka.&#10; * @param shm Ukazovateľ na zdieľanú štruktúru.&#10; */&#10;void vykonaj_sumarnu_simulaciu(ZdielaneData_t* shm);&#10;&#10;#endif" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ipc_shm.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ipc_shm.c" />
              <option name="originalContent" value="//&#10;// Created by damko on 16/12/2025.&#10;//&#10;&#10;#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;sys/ipc.h&gt;&#10;#include &lt;sys/shm.h&gt;&#10;#include &lt;sys/sem.h&gt;&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;errno.h&gt;&#10;&#10;#include &quot;headers/ipc_shm.h&quot;&#10;#include &quot;headers/common.h&quot;&#10;&#10;#define SHM_KEY 1234 //nahodny kluc pre identifikaciu pamate&#10;&#10;/**&#10; * @brief Vytvorí a pripojí segment zdieľanej pamäte pre štruktúru ZdielaneData_t.&#10; *&#10; * Alokuje segment SHM pomocou `shmget`, pripojí ho pomocou `shmat`, vyčistí&#10; * obsah na nulu a inicializuje potrebné semafory (`shm_mutex`, `data_ready`).&#10; *&#10; * @param key Kľúč používaný pre `shmget`.&#10; * @return Ukazovateľ na pripojený segment typu `ZdielaneData_t` alebo NULL pri chybe.&#10; */&#10;ZdielaneData_t* shm_create_and_attach(key_t key) {&#10;    int shm_id;&#10;    ZdielaneData_t* shm_ptr;&#10;&#10;    //vytvorenie segmentu zdielanej pamate&#10;    shm_id = shmget(key, sizeof(ZdielaneData_t), IPC_CREAT | 0666);&#10;    if (shm_id &lt; 0) {&#10;        perror(&quot;shmget: Chyba pri vytvoreni segmentu SHM\n&quot;);&#10;        return NULL;&#10;    }&#10;&#10;    //pripojenie segmentu k adresnemu priestoru procesu&#10;    shm_ptr = (ZdielaneData_t*) shmat(shm_id, NULL, 0);&#10;    if (shm_ptr == (void*) -1) {&#10;        perror(&quot;shmat: Chyba pri pripojeni segmentu SHM&quot;);&#10;        return NULL;&#10;    }&#10;&#10;    //vymaze vsetko co v pamati zostalo z predchadzajucich spusteni&#10;    memset(shm_ptr, 0, sizeof(ZdielaneData_t));&#10;&#10;    //inicializacia semaforov&#10;    //shm_mutex: pshared=1 (zdielany medzi procesmi), hodnota=1 (odomknuty)&#10;    if (sem_init(&amp;shm_ptr-&gt;shm_mutex, 1, 1) == -1) {&#10;        perror(&quot;sem_init mutex&quot;);&#10;    }&#10;&#10;    //data_ready: pshared=1 hodnota=0 (klient caka kym server nieco nevyrobi)&#10;    if (sem_init(&amp;shm_ptr-&gt;data_ready, 1, 0) != 0) {&#10;        perror(&quot;sem_init data_ready&quot;);&#10;    }&#10;&#10;    return shm_ptr;&#10;}&#10;&#10;/**&#10; * @brief Odpojí a (ak je to možné) odstráni segment zdieľanej pamäte z OS.&#10; *&#10; * Funkcia bezpečne odpojí segment SHM (shmdt) a pokúsi sa nastaviť príznak&#10; * na odstránenie segmentu (IPC_RMID). Ak segment už neexistuje, ignoruje chybu.&#10; *&#10; * @param shm_ptr Ukazovateľ na pripojený segment.&#10; * @param key Kľúč, ktorý sa použije na získanie ID segmentu pri odstraňovaní.&#10; */&#10;void shm_detach_and_destroy(ZdielaneData_t* shm_ptr, key_t key) {&#10;    if (shm_ptr == NULL) {&#10;        return;&#10;    }&#10;    // 1. Odpojenie pamäte od adresného priestoru tohto konkrétneho procesu&#10;    if (shmdt(shm_ptr) == -1) {&#10;        perror(&quot;shmdt&quot;);&#10;    }&#10;&#10;    // 2. Úplné odstránenie segmentu zo systému (len jeden proces by mal toto robiť)&#10;    // Získame ID segmentu znova pre istotu&#10;    int shm_id = shmget(key, 0, 0666);&#10;    if (shm_id != -1) {&#10;        // Kontrola, či už nie je označený na zmazanie nie je nutná,&#10;        // ale IPC_RMID je bezpečné volať viackrát (vráti chybu ak už neexistuje)&#10;        if (shmctl(shm_id, IPC_RMID, NULL) == -1) {&#10;            // Ak to zlyhá, pravdepodobne to už iný proces odstránil (napr. server po ukončení)&#10;            if (errno != EINVAL) perror(&quot;shmctl IPC_RMID&quot;);&#10;        } else {&#10;            printf(&quot;[IPC] Zdieľaná pamäť bola úplne odstránená zo systému.\n&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Zničí inicializované semafory v zdieľanej štruktúre.&#10; *&#10; * Zavolá `sem_destroy` pre `shm_mutex` a `data_ready` ak `shm_ptr` nie je NULL.&#10; *&#10; * @param shm_ptr Ukazovateľ na pripojený segment.&#10; */&#10;void shm_cleanup_semaphores(ZdielaneData_t* shm_ptr) {&#10;    if (shm_ptr != NULL) {&#10;        sem_destroy(&amp;shm_ptr-&gt;shm_mutex);&#10;        sem_destroy(&amp;shm_ptr-&gt;data_ready);&#10;    }&#10;}" />
              <option name="updatedContent" value="//&#10;// Created by damko on 16/12/2025.&#10;//&#10;&#10;#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;sys/ipc.h&gt;&#10;#include &lt;sys/shm.h&gt;&#10;#include &lt;sys/sem.h&gt;&#10;#include &lt;semaphore.h&gt;&#10;#include &lt;errno.h&gt;&#10;&#10;#include &quot;headers/ipc_shm.h&quot;&#10;#include &quot;headers/common.h&quot;&#10;&#10;#define SHM_KEY 1234 //nahodny kluc pre identifikaciu pamate&#10;&#10;/**&#10; * @brief Vytvorí a pripojí segment zdieľanej pamäte pre štruktúru ZdielaneData_t.&#10; *&#10; * Alokuje segment SHM pomocou `shmget`, pripojí ho pomocou `shmat`, vyčistí&#10; * obsah na nulu a inicializuje potrebné semafory (`shm_mutex`, `data_ready`).&#10; *&#10; * @param key Kľúč používaný pre `shmget`.&#10; * @return Ukazovateľ na pripojený segment typu `ZdielaneData_t` alebo NULL pri chybe.&#10; */&#10;ZdielaneData_t* shm_create_and_attach(key_t key) {&#10;    int shm_id;&#10;    ZdielaneData_t* shm_ptr;&#10;&#10;    //vytvorenie segmentu zdielanej pamate&#10;    shm_id = shmget(key, sizeof(ZdielaneData_t), IPC_CREAT | 0666);&#10;    if (shm_id &lt; 0) {&#10;        perror(&quot;shmget: Chyba pri vytvoreni segmentu SHM\n&quot;);&#10;        return NULL;&#10;    }&#10;&#10;    //pripojenie segmentu k adresnemu priestoru procesu&#10;    shm_ptr = (ZdielaneData_t*) shmat(shm_id, NULL, 0);&#10;    if (shm_ptr == (void*) -1) {&#10;        perror(&quot;shmat: Chyba pri pripojeni segmentu SHM&quot;);&#10;        return NULL;&#10;    }&#10;&#10;    //vymaze vsetko co v pamati zostalo z predchadzajucich spusteni&#10;    memset(shm_ptr, 0, sizeof(ZdielaneData_t));&#10;&#10;    //inicializacia semaforov&#10;    //shm_mutex: pshared=1 (zdielany medzi procesmi), hodnota=1 (odomknuty)&#10;    if (sem_init(&amp;shm_ptr-&gt;shm_mutex, 1, 1) == -1) {&#10;        perror(&quot;sem_init mutex&quot;);&#10;    }&#10;&#10;    //data_ready: pshared=1 hodnota=0 (klient caka kym server nieco nevyrobi)&#10;    if (sem_init(&amp;shm_ptr-&gt;data_ready, 1, 0) != 0) {&#10;        perror(&quot;sem_init data_ready&quot;);&#10;    }&#10;&#10;    return shm_ptr;&#10;}&#10;&#10;/**&#10; * @brief Odpojí a (ak je to možné) odstráni segment zdieľanej pamäte z OS.&#10; *&#10; * Funkcia bezpečne odpojí segment SHM (shmdt) a pokúsi sa nastaviť príznak&#10; * na odstránenie segmentu (IPC_RMID). Ak segment už neexistuje, ignoruje chybu.&#10; *&#10; * @param shm_ptr Ukazovateľ na pripojený segment.&#10; * @param key Kľúč, ktorý sa použije na získanie ID segmentu pri odstraňovaní.&#10; */&#10;void shm_detach_and_destroy(ZdielaneData_t* shm_ptr, key_t key) {&#10;    if (shm_ptr == NULL) {&#10;        return;&#10;    }&#10;    // 1. Odpojenie pamäte od adresného priestoru tohto konkrétneho procesu&#10;    if (shmdt(shm_ptr) == -1) {&#10;        perror(&quot;shmdt&quot;);&#10;    }&#10;&#10;    // 2. Úplné odstránenie segmentu zo systému (len jeden proces by mal toto robiť)&#10;    // Získame ID segmentu znova pre istotu&#10;    int shm_id = shmget(key, 0, 0666);&#10;    if (shm_id != -1) {&#10;        // Kontrola, či už nie je označený na zmazanie nie je nutná,&#10;        // ale IPC_RMID je bezpečné volať viackrát (vráti chybu ak už neexistuje)&#10;        if (shmctl(shm_id, IPC_RMID, NULL) == -1) {&#10;            // Ak to zlyhá, pravdepodobne to už iný proces odstránil (napr. server po ukončení)&#10;            if (errno != EINVAL) perror(&quot;shmctl IPC_RMID&quot;);&#10;        } else {&#10;            printf(&quot;[IPC] Zdieľaná pamäť bola úplne odstránená zo systému.\n&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Zničí inicializované semafory v zdieľanej štruktúre.&#10; *&#10; * Zavolá `sem_destroy` pre `shm_mutex` a `data_ready` ak `shm_ptr` nie je NULL.&#10; *&#10; * @param shm_ptr Ukazovateľ na pripojený segment.&#10; */&#10;void shm_cleanup_semaphores(ZdielaneData_t* shm_ptr) {&#10;    if (shm_ptr != NULL) {&#10;        sem_destroy(&amp;shm_ptr-&gt;shm_mutex);&#10;        sem_destroy(&amp;shm_ptr-&gt;data_ready);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/menu.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/menu.c" />
              <option name="originalContent" value="#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;&#10;#include &quot;headers/client_menu.h&quot;&#10;&#10;/**&#10; * @brief Bezpečne načíta celé číslo z konzoly v zadanom rozsahu.&#10; *&#10; * Funkcia opakuje výzvu kým používateľ nezadá platné celé číslo v intervale&#10; * [min, max]. Pri neplatnom vstupe vyprázdni vstupný buffer a vypíše chybovú správu.&#10; *&#10; * @param otazka Text výzvy, ktorý sa vypíše používateľovi.&#10; * @param min Minimálna povolená hodnota (vrátane).&#10; * @param max Maximálna povolená hodnota (vrátane).&#10; * @return Načítaná celočíselná hodnota v rozsahu [min, max].&#10; */&#10;int nacitaj_cele_cislo(const char* otazka, int min, int max) {&#10;    int hodnota;&#10;    while (1) {&#10;        printf(&quot;%s&quot;, otazka);&#10;        if (scanf(&quot;%d&quot;, &amp;hodnota) != 1) {&#10;            printf(&quot;CHYBA: Zadaj cele cislo!\n&quot;);&#10;            while (getchar() != '\n');&#10;            continue;&#10;        }&#10;        if (hodnota &lt; min || hodnota &gt; max) {&#10;            printf(&quot;CHYBA: Hodnota musi byt v rozsahu %d az %d!\n&quot;, min, max);&#10;            continue;&#10;        }&#10;        return hodnota;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Načíta názov súboru od používateľa s kontrolou prípony &quot;.txt&quot;.&#10; *&#10; * Opakuje výzvu až kým používateľ nezadá reťazec končiaci na &quot;.txt&quot;.&#10; * Výsledný názov je uložený do bufferu `kam_ulozit` (max 255 znakov).&#10; *&#10; * @param kam_ulozit Buffer kam sa uloží zadaný názov súboru (min veľkosť 256).&#10; * @param text_vyzvy Text výzvy, ktorý sa vypíše používateľovi.&#10; */&#10;void nacitaj_nazov_suboru(char* kam_ulozit, const char* text_vyzvy) {&#10;    while (1) {&#10;        printf(&quot;%s (musi koncit na .txt): &quot;, text_vyzvy);&#10;        scanf(&quot;%255s&quot;, kam_ulozit);&#10;        char *p = strstr(kam_ulozit, &quot;.txt&quot;);&#10;        if (p != NULL &amp;&amp; strlen(p) == 4) {&#10;            break;&#10;        }&#10;        printf(&quot;CHYBA: Neplatny nazov suboru!\n&quot;);&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Načíta a validuje štyri smerové pravdepodobnosti z konzoly.&#10; *&#10; * Požiada používateľa o pravdepodobnosti pre smery &quot;Hore&quot;, &quot;Dole&quot;, &quot;Vlavo&quot;, &quot;Vpravo&quot;.&#10; * Hodnoty sa zadávajú ako desatinné čísla s bodkou (napr. 0.25). Funkcia zabezpečí,&#10; * že každá hodnota je v intervale [0.0, 1.0] a že súčet všetkých štyroch hodnôt je&#10; * približne 1.0 (povolená odchýlka 0.001).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť, kde sú pravdepodobnosti uložené do `shm-&gt;pravdepodobnost`.&#10; */&#10;void nacitaj_pravdepodobnosti(ZdielaneData_t* shm) {&#10;    double suma;&#10;    char vstup_text[20];&#10;    char* smery[] = {&quot;Hore&quot;, &quot;Dole&quot;, &quot;Vlavo&quot;, &quot;Vpravo&quot;};&#10;&#10;    do {&#10;        suma = 0;&#10;        printf(&quot;\nZadaj pravdepodobnosti pohybu (sucet musi byt 1.0):\n&quot;);&#10;        for (int i = 0; i &lt; 4; i++) {&#10;            while (1) {&#10;                printf(&quot;Pravdepodobnost pre %s: &quot;, smery[i]);&#10;                scanf(&quot; %19s&quot;, vstup_text);&#10;                if (strchr(vstup_text, ',')) {&#10;                    printf(&quot;CHYBA: Pouzivaj bodku!\n&quot;);&#10;                    continue;&#10;                }&#10;                char* endptr;&#10;                double hodnota = strtod(vstup_text, &amp;endptr);&#10;                if (vstup_text == endptr || hodnota &lt; 0.0 || hodnota &gt; 1.0) {&#10;                    printf(&quot;CHYBA: Neplatna hodnota!\n&quot;);&#10;                    continue;&#10;                }&#10;                shm-&gt;pravdepodobnost[i] = hodnota;&#10;                suma += hodnota;&#10;                break;&#10;            }&#10;        }&#10;    } while (suma &lt; 0.999 || suma &gt; 1.001);&#10;}&#10;&#10;/**&#10; * @brief Zobrazí počiatočné menu a načíta nastavenia simulácie od používateľa.&#10; *&#10; * Funkcia obsluhuje výber medzi novou náhodnou simuláciou a opätovným spustením&#10; * zo súboru. Podľa zvoleného módu vyzve používateľa na relevantné parametre&#10; * (počet replikácií, kroky, hustota prekážok, rozmery mapy, pravdepodobnosti).&#10; * Výsledok uloží do zdieľanej pamäte `shm` a nastaví `shm-&gt;stav = SIM_INIT`.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť, kam sa uložia zvolené nastavenia.&#10; */&#10;void zobraz_pociatocne_menu(ZdielaneData_t* shm) {&#10;    printf(&quot;=== HLAVNE MENU ===\n&quot;);&#10;    printf(&quot;1 - Nova nahodna simulacia\n&quot;);&#10;    printf(&quot;2 - Opatovne spustenie (nacitat zo suboru)\n&quot;);&#10;&#10;    int volba = nacitaj_cele_cislo(&quot;Tvoja volba: &quot;, 1, 2);&#10;    shm-&gt;opetovne_spustenie = (volba == 2);&#10;&#10;    if (shm-&gt;opetovne_spustenie) {&#10;        nacitaj_nazov_suboru(shm-&gt;nazov_suboru, &quot;Zadaj nazov suboru pre NACITANIE&quot;);&#10;        shm-&gt;mod = (nacitaj_cele_cislo(&quot;Mod (0-Interaktivny., 1-Sumarny.): &quot;, 0, 1) == 0) ? INTERAKTIVNY : SUMARNY;&#10;    } else {&#10;        printf(&quot;\n=== NASTAVENIA NOVEJ SIMULACIE ===\n&quot;);&#10;&#10;        shm-&gt;mod = (nacitaj_cele_cislo(&quot;Mod (0-Interaktivny., 1-Sumarny.): &quot;, 0, 1) == 0) ? INTERAKTIVNY : SUMARNY;&#10;        nacitaj_nazov_suboru(shm-&gt;nazov_suboru, &quot;Zadaj nazov suboru pre ULOZENIE&quot;);&#10;&#10;        if (shm-&gt;mod == SUMARNY) {&#10;            shm-&gt;total_replikacie = nacitaj_cele_cislo(&quot;Zadaj pocet replikacii: &quot;, 1, 1000000);&#10;        } else {&#10;            shm-&gt;total_replikacie = 1;&#10;        }&#10;&#10;        shm-&gt;K_max_kroky = nacitaj_cele_cislo(&quot;Max. pocet krokov: &quot;, 1, 1000000);&#10;        shm-&gt;pocet_prekazok = nacitaj_cele_cislo(&quot;Hustota prekazok (0-50%): &quot;, 0, 50);&#10;        shm-&gt;riadky = nacitaj_cele_cislo(&quot;Pocet riadkov: &quot;, 1, MAX_ROWS);&#10;        shm-&gt;stlpece = nacitaj_cele_cislo(&quot;Pocet stlpcov: &quot;, 1, MAX_COLS);&#10;&#10;        nacitaj_pravdepodobnosti(shm);&#10;    }&#10;&#10;    shm-&gt;stav = SIM_INIT;&#10;    printf(&quot;\n[MENU] Nastavenia pripravene, simulacia startuje...\n&quot;);&#10;}" />
              <option name="updatedContent" value="#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;&#10;#include &quot;headers/client_menu.h&quot;&#10;&#10;/**&#10; * @brief Bezpečne načíta celé číslo z konzoly v zadanom rozsahu.&#10; *&#10; * Funkcia opakuje výzvu kým používateľ nezadá platné celé číslo v intervale&#10; * [min, max]. Pri neplatnom vstupe vyprázdni vstupný buffer a vypíše chybovú správu.&#10; *&#10; * @param otazka Text výzvy, ktorý sa vypíše používateľovi.&#10; * @param min Minimálna povolená hodnota (vrátane).&#10; * @param max Maximálna povolená hodnota (vrátane).&#10; * @return Načítaná celočíselná hodnota v rozsahu [min, max].&#10; */&#10;int nacitaj_cele_cislo(const char* otazka, int min, int max) {&#10;    int hodnota;&#10;    while (1) {&#10;        printf(&quot;%s&quot;, otazka);&#10;        if (scanf(&quot;%d&quot;, &amp;hodnota) != 1) {&#10;            printf(&quot;CHYBA: Zadaj cele cislo!\n&quot;);&#10;            while (getchar() != '\n');&#10;            continue;&#10;        }&#10;        if (hodnota &lt; min || hodnota &gt; max) {&#10;            printf(&quot;CHYBA: Hodnota musi byt v rozsahu %d az %d!\n&quot;, min, max);&#10;            continue;&#10;        }&#10;        return hodnota;&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Načíta názov súboru od používateľa s kontrolou prípony &quot;.txt&quot;.&#10; *&#10; * Opakuje výzvu až kým používateľ nezadá reťazec končiaci na &quot;.txt&quot;.&#10; * Výsledný názov je uložený do bufferu `kam_ulozit` (max 255 znakov).&#10; *&#10; * @param kam_ulozit Buffer kam sa uloží zadaný názov súboru (min veľkosť 256).&#10; * @param text_vyzvy Text výzvy, ktorý sa vypíše používateľovi.&#10; */&#10;void nacitaj_nazov_suboru(char* kam_ulozit, const char* text_vyzvy) {&#10;    while (1) {&#10;        printf(&quot;%s (musi koncit na .txt): &quot;, text_vyzvy);&#10;        scanf(&quot;%255s&quot;, kam_ulozit);&#10;        char *p = strstr(kam_ulozit, &quot;.txt&quot;);&#10;        if (p != NULL &amp;&amp; strlen(p) == 4) {&#10;            break;&#10;        }&#10;        printf(&quot;CHYBA: Neplatny nazov suboru!\n&quot;);&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Načíta a validuje štyri smerové pravdepodobnosti z konzoly.&#10; *&#10; * Požiada používateľa o pravdepodobnosti pre smery &quot;Hore&quot;, &quot;Dole&quot;, &quot;Vlavo&quot;, &quot;Vpravo&quot;.&#10; * Hodnoty sa zadávajú ako desatinné čísla s bodkou (napr. 0.25). Funkcia zabezpečí,&#10; * že každá hodnota je v intervale [0.0, 1.0] a že súčet všetkých štyroch hodnôt je&#10; * približne 1.0 (povolená odchýlka 0.001).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť, kde sú pravdepodobnosti uložené do `shm-&gt;pravdepodobnost`.&#10; */&#10;void nacitaj_pravdepodobnosti(ZdielaneData_t* shm) {&#10;    double suma;&#10;    char vstup_text[20];&#10;    char* smery[] = {&quot;Hore&quot;, &quot;Dole&quot;, &quot;Vlavo&quot;, &quot;Vpravo&quot;};&#10;&#10;    do {&#10;        suma = 0;&#10;        printf(&quot;\nZadaj pravdepodobnosti pohybu (sucet musi byt 1.0):\n&quot;);&#10;        for (int i = 0; i &lt; 4; i++) {&#10;            while (1) {&#10;                printf(&quot;Pravdepodobnost pre %s: &quot;, smery[i]);&#10;                scanf(&quot; %19s&quot;, vstup_text);&#10;                if (strchr(vstup_text, ',')) {&#10;                    printf(&quot;CHYBA: Pouzivaj bodku!\n&quot;);&#10;                    continue;&#10;                }&#10;                char* endptr;&#10;                double hodnota = strtod(vstup_text, &amp;endptr);&#10;                if (vstup_text == endptr || hodnota &lt; 0.0 || hodnota &gt; 1.0) {&#10;                    printf(&quot;CHYBA: Neplatna hodnota!\n&quot;);&#10;                    continue;&#10;                }&#10;                shm-&gt;pravdepodobnost[i] = hodnota;&#10;                suma += hodnota;&#10;                break;&#10;            }&#10;        }&#10;    } while (suma &lt; 0.999 || suma &gt; 1.001);&#10;}&#10;&#10;/**&#10; * @brief Zobrazí počiatočné menu a načíta nastavenia simulácie od používateľa.&#10; *&#10; * Funkcia obsluhuje výber medzi novou náhodnou simuláciou a opätovným spustením&#10; * zo súboru. Podľa zvoleného módu vyzve používateľa na relevantné parametre&#10; * (počet replikácií, kroky, hustota prekážok, rozmery mapy, pravdepodobnosti).&#10; * Výsledok uloží do zdieľanej pamäte `shm` a nastaví `shm-&gt;stav = SIM_INIT`.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú pamäť, kam sa uložia zvolené nastavenia.&#10; */&#10;void zobraz_pociatocne_menu(ZdielaneData_t* shm) {&#10;    printf(&quot;=== HLAVNE MENU ===\n&quot;);&#10;    printf(&quot;1 - Nova nahodna simulacia\n&quot;);&#10;    printf(&quot;2 - Opatovne spustenie (nacitat zo suboru)\n&quot;);&#10;&#10;    int volba = nacitaj_cele_cislo(&quot;Tvoja volba: &quot;, 1, 2);&#10;    shm-&gt;opetovne_spustenie = (volba == 2);&#10;&#10;    if (shm-&gt;opetovne_spustenie) {&#10;        nacitaj_nazov_suboru(shm-&gt;nazov_suboru, &quot;Zadaj nazov suboru pre NACITANIE&quot;);&#10;        shm-&gt;mod = (nacitaj_cele_cislo(&quot;Mod (0-Interaktivny., 1-Sumarny.): &quot;, 0, 1) == 0) ? INTERAKTIVNY : SUMARNY;&#10;    } else {&#10;        printf(&quot;\n=== NASTAVENIA NOVEJ SIMULACIE ===\n&quot;);&#10;&#10;        shm-&gt;mod = (nacitaj_cele_cislo(&quot;Mod (0-Interaktivny., 1-Sumarny.): &quot;, 0, 1) == 0) ? INTERAKTIVNY : SUMARNY;&#10;        nacitaj_nazov_suboru(shm-&gt;nazov_suboru, &quot;Zadaj nazov suboru pre ULOZENIE&quot;);&#10;&#10;        if (shm-&gt;mod == SUMARNY) {&#10;            shm-&gt;total_replikacie = nacitaj_cele_cislo(&quot;Zadaj pocet replikacii: &quot;, 1, 1000000);&#10;        } else {&#10;            shm-&gt;total_replikacie = 1;&#10;        }&#10;&#10;        shm-&gt;K_max_kroky = nacitaj_cele_cislo(&quot;Max. pocet krokov: &quot;, 1, 1000000);&#10;        shm-&gt;pocet_prekazok = nacitaj_cele_cislo(&quot;Hustota prekazok (0-50%): &quot;, 0, 50);&#10;        shm-&gt;riadky = nacitaj_cele_cislo(&quot;Pocet riadkov: &quot;, 1, MAX_ROWS);&#10;        shm-&gt;stlpece = nacitaj_cele_cislo(&quot;Pocet stlpcov: &quot;, 1, MAX_COLS);&#10;&#10;        nacitaj_pravdepodobnosti(shm);&#10;    }&#10;&#10;    shm-&gt;stav = SIM_INIT;&#10;    printf(&quot;\n[MENU] Nastavenia pripravene, simulacia startuje...\n&quot;);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server.c" />
              <option name="originalContent" value="#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;time.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &quot;headers/ipc_shm.h&quot;&#10;&#10;/**&#10; * @brief Uloží výsledky simulácie a konfiguráciu sveta do súboru.&#10; *&#10; * Ak `shm-&gt;nazov_suboru` je prázdny reťazec, funkcia nič nerobí.&#10; * Do súboru uloží rozmery mapy, nastavenia replikácií a krokov, počet&#10; * prekážok, pravdepodobnosti pohybov, mapu sveta (0 = prázdne, 1 = prekážka)&#10; * a agregované výsledky pre každé políčko (priemerný počet krokov a&#10; * percento úspešnosti).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu výsledky a konfiguráciu.&#10; */&#10;void uloz_vysledky_do_suboru(ZdielaneData_t* shm) {&#10;    //ak nezadal nazov&#10;    if (shm-&gt;nazov_suboru[0] == '\0') {&#10;        return;&#10;    }&#10;&#10;    FILE * file = fopen(shm-&gt;nazov_suboru, &quot;w&quot;);&#10;    if (file == NULL) {&#10;        perror(&quot;Nepodarilo sa otvorit subor na zapis&quot;);&#10;        return;&#10;    }&#10;&#10;    //uloz zakladne parametre&#10;    fprintf(file, &quot;%d %d\n&quot;, shm-&gt;riadky, shm-&gt;stlpece);&#10;    fprintf(file, &quot;%d %d\n&quot;, shm-&gt;total_replikacie, shm-&gt;K_max_kroky);&#10;    fprintf(file, &quot;%d\n&quot;, shm-&gt;pocet_prekazok); // preistotu aj ked nacitavam tu ulozenu mapu&#10;    fprintf(file, &quot;%f %f %f %f \n&quot;, shm-&gt;pravdepodobnost[0], shm-&gt;pravdepodobnost[1], shm-&gt;pravdepodobnost[2], shm-&gt;pravdepodobnost[3]);&#10;&#10;    //ulozenie mapy sveta (0 = prazdne, 1 = prekazka)&#10;    for (int i = 0; i &lt; shm-&gt;riadky; i++) {&#10;        for (int j = 0; j &lt; shm-&gt;stlpece; j++) {&#10;            fprintf(file, &quot;%d &quot;, shm-&gt;svet[i][j]);&#10;        }&#10;        fprintf(file, &quot;\n&quot;);&#10;    }&#10;&#10;    //ulozenie vysledkov&#10;    fprintf(file, &quot;--- VYSLEDKY ---\n&quot;);&#10;    for (int i = 0; i &lt; shm-&gt;riadky; i++) {&#10;        for (int j = 0; j &lt; shm-&gt;stlpece; j++) {&#10;            double avg = (double)shm-&gt;vysledky[i][j].avg_kroky / shm-&gt;total_replikacie;&#10;            double pravdepodobnost = ((double)shm-&gt;vysledky[i][j].pravdepodobnost_dosiahnutia / shm-&gt;total_replikacie * 100);&#10;            fprintf(file, &quot;%.2f(%.0f%%) &quot;, avg, pravdepodobnost);&#10;        }&#10;        fprintf(file, &quot;\n&quot;);&#10;    }&#10;    fclose(file);&#10;    printf(&quot;[SERVER] Vysledky boli ulozene do suboru: %s\n&quot;, shm-&gt;nazov_suboru);&#10;}&#10;&#10;/**&#10; * @brief Načíta konfiguráciu a mapu sveta zo súboru do zdieľanej pamäte.&#10; *&#10; * Očakáva formát uložený funkciou `uloz_vysledky_do_suboru`. V prípade&#10; * chyby pri čítaní alebo parsovaní vráti false a zatvorí súbor.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru, kam sa načítajú hodnoty.&#10; * @return true ak bolo načítanie úspešné, inak false.&#10; */&#10;bool nacitaj_konfig_zo_suboru(ZdielaneData_t* shm) {&#10;    FILE* file = fopen(shm-&gt;nazov_suboru, &quot;r&quot;);&#10;    if (file == NULL) {&#10;        perror(&quot;Nepodarilo sa otvorit subor na citanie&quot;);&#10;        return false;&#10;    }&#10;&#10;    //nacitanie zakladnych parametrov (riadky, stlpce, replikacie, kroky)&#10;    if (fscanf(file, &quot;%d %d&quot;, &amp;shm-&gt;riadky, &amp;shm-&gt;stlpece) != 2) {&#10;        fclose(file);&#10;        return false;&#10;    }&#10;    if (fscanf(file, &quot;%d %d&quot;, &amp;shm-&gt;total_replikacie, &amp;shm-&gt;K_max_kroky) != 2) {&#10;        fclose(file);&#10;        return false;&#10;    }&#10;&#10;    //nacitanie hustoty prekazok aj ked ju pri nacitani nepouzivam&#10;    if (fscanf(file, &quot;%d&quot;, &amp;shm-&gt;pocet_prekazok) != 1) {&#10;        fclose(file);&#10;        return false;&#10;    }&#10;&#10;    //nacitanie pravdepodobnosti pohybu (pouzivam float docasne kvoli fscanf potom convert do double)&#10;    float p0, p1, p2, p3;&#10;    if (fscanf(file, &quot;%f %f %f %f&quot;, &amp;p0, &amp;p1, &amp;p2, &amp;p3) != 4) {&#10;        fclose(file);&#10;        return false;&#10;    }&#10;    shm-&gt;pravdepodobnost[0] = p0;&#10;    shm-&gt;pravdepodobnost[1] = p1;&#10;    shm-&gt;pravdepodobnost[2] = p2;&#10;    shm-&gt;pravdepodobnost[3] = p3;&#10;&#10;    //nacitanie mapy sveta (0 = prazdne, 1 = prekazka)&#10;    for (int i = 0; i &lt; shm-&gt;riadky; i++) {&#10;        for (int j = 0; j &lt; shm-&gt;stlpece; j++) {&#10;            int hodnota;&#10;            if (fscanf(file, &quot;%d&quot;, &amp;hodnota) != 1) {&#10;                fclose(file);&#10;                return false;&#10;            }&#10;            shm-&gt;svet[i][j] = hodnota;&#10;        }&#10;    }&#10;    //vysledky ma nezaujimaju pre novu simulacii takze zatvaram&#10;    fclose(file);&#10;    return true;&#10;}&#10;&#10;/**&#10; * @brief Overí, či je svet priechodný (všetky neprekážkové políčka dosiahnuteľné z [0,0]).&#10; *&#10; * Používa BFS na toroidnej mriežke (okraje sa &quot;zabalia&quot;). Porovná počet&#10; * navštívených políčok s počtom voľných políčok v mape.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu mapu a rozmery.&#10; * @return true ak sú všetky neprekážkové políčka dosiahnuteľné, inak false.&#10; */&#10;bool je_svet_validny(ZdielaneData_t* shm) {&#10;    int riadky = shm-&gt;riadky;&#10;    int stlpce = shm-&gt;stlpece;&#10;&#10;    //spocitanie kolko volnych policok vratane ciela v mape je&#10;    int celkovy_pocet = 0;&#10;    for (int riadok = 0; riadok &lt; riadky; riadok++) {&#10;        for (int stlpec = 0; stlpec &lt; stlpce; stlpec++) {&#10;            if (shm-&gt;svet[riadok][stlpec] != PREKAZKA) {&#10;                celkovy_pocet++;&#10;            }&#10;        }&#10;    }&#10;&#10;    //BFS priprava&#10;    bool navstivene[MAX_ROWS][MAX_COLS] = {false};&#10;    int front_r[MAX_ROWS * MAX_COLS];&#10;    int front_s[MAX_ROWS * MAX_COLS];&#10;    int zaciatok = 0;&#10;    int koniec = 0;&#10;&#10;    //start z [0,0]&#10;    front_r[koniec] = 0;&#10;    front_s[koniec] = 0;&#10;    koniec++;&#10;    navstivene[0][0] = true;&#10;    int dosiahnutelnych = 1;&#10;&#10;    //rozlievanie cez BFS&#10;    while (zaciatok &lt; koniec) {&#10;        int riadok = front_r[zaciatok];&#10;        int stlpec = front_s[zaciatok];  //oprava indexu po zaciatok++&#10;&#10;        zaciatok++;&#10;&#10;        int posun_riadok[] = {-1, 1, 0, 0};&#10;        int posun_stlpec[] = {0, 0, -1, 1};&#10;&#10;        for (int i = 0; i &lt; 4; i++) {&#10;            //toroidny sused&#10;            int novy_riadok = ((riadok + posun_riadok[i] + riadky) % riadky);&#10;            int novy_stlpec = ((stlpec + posun_stlpec[i] + stlpce) % stlpce);&#10;&#10;            if (shm-&gt;svet[novy_riadok][novy_stlpec] != PREKAZKA &amp;&amp; !navstivene[novy_riadok][novy_stlpec]) {&#10;                navstivene[novy_riadok][novy_stlpec] = true;&#10;                front_r[koniec] = novy_riadok;&#10;                front_s[koniec] = novy_stlpec;&#10;                koniec++;&#10;                dosiahnutelnych++;&#10;            }&#10;        }&#10;    }&#10;    //ak som sa dostal na vsetky volne policka mapa je v poriadku&#10;    return (dosiahnutelnych == celkovy_pocet);&#10;}&#10;&#10;/**&#10; * @brief Vyberie smer pohybu na základe nastavených pravdepodobností.&#10; *&#10; * Generuje náhodné číslo v [0,1) a vráti index smeru podľa kumulatívnych&#10; * pravdepodobností v poli `shm-&gt;pravdepodobnost`.&#10; * Indexy sú mapované takto: 0 = HORE, 1 = DOLE, 2 = VLAVO, 3 = VPRAVO.&#10; * Ako poistka vráti 3 (VPRAVO) pre prípad zaokrúhľovacích chýb.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu pole pravdepodobností.&#10; * @return Číslo v rozsahu 0..3 reprezentujúce smer.&#10; */&#10;int vyber_smeru(ZdielaneData_t* shm) {&#10;    double r = (double)rand() / RAND_MAX;&#10;    double kumulativna_suma = 0;&#10;&#10;    for (int i = 0; i &lt; 4; i++) {&#10;        kumulativna_suma += shm-&gt;pravdepodobnost[i];&#10;        if (r &lt;= kumulativna_suma) {&#10;            return i; //vrati 0(HORE) 1(DOLE) 2(Vlavo) 3(Vpravo)&#10;        }&#10;    }&#10;    return 3; // Poistka pre zaokrúhľovacie chyby (Vpravo)&#10;}&#10;&#10;/**&#10; * @brief Vygeneruje náhodný svet s prekážkami podľa percenta.&#10; *&#10; * Každé políčko (okrem cieľa [0,0] a stredu mapy) sa nastaví na prekážku&#10; * s pravdepodobnosťou `percento_prekazok` percent. Hodnoty sa ukladajú do&#10; * `shm-&gt;svet` (PRAZDNE alebo PREKAZKA).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu rozmery a mapu.&#10; * @param percento_prekazok Celé percento (0-100) šance, že políčko bude prekážka.&#10; */&#10;void generuj_svet_s_prekazkami(ZdielaneData_t* shm, int percento_prekazok) {&#10;    for (int riadok = 0; riadok &lt; shm-&gt;riadky; riadok++) {&#10;        for (int stlpec = 0; stlpec &lt; shm-&gt;stlpece; stlpec++) {&#10;&#10;            //ochrana aby ciel [0,0] nemohol byt prekazka&#10;            if (riadok == 0 &amp;&amp; stlpec == 0) {&#10;                shm-&gt;svet[riadok][stlpec] = PRAZDNE;&#10;                continue;&#10;            }&#10;&#10;            //vynechanie stred mriezky aby chodec nezacinal v stene&#10;            if (riadok == shm-&gt;riadky / 2 &amp;&amp; stlpec == shm-&gt;stlpece / 2) {&#10;                shm-&gt;svet[riadok][stlpec] = PRAZDNE;&#10;                continue;&#10;            }&#10;            //nahodne rozhodnutie ci na policku bude prekazka&#10;            if ((rand() % 100) &lt; percento_prekazok) {&#10;                shm-&gt;svet[riadok][stlpec] = PREKAZKA;&#10;            } else {&#10;                shm-&gt;svet[riadok][stlpec] = PRAZDNE;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Simuluje jedného chodca z daného štartovacieho políčka.&#10; *&#10; * Hlavný simulačný cyklus pohybuje chodcom, kontroluje kolízie s prekážkami&#10; * a v interaktívnom režime aktualizuje pozíciu cez semafory pre klienta.&#10; * Po skončení replikácie aktualizuje štatistiky (priemerné kroky a počet úspechov)&#10; * pre štartovacie políčko.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru s konfiguráciou a výsledkami.&#10; * @param start_r Počiatočný riadok chodca.&#10; * @param start_s Počiatočný stĺpec chodca.&#10; */&#10;void simuluj_chodzu_z_policka(ZdielaneData_t* shm, int start_r, int start_s) {&#10;    int aktualny_r = start_r;&#10;    int aktualny_s = start_s;&#10;    int pocet_krok = 0;&#10;&#10;    //zobrazenie startovacej pozicie chodcu&#10;    if (shm-&gt;mod == INTERAKTIVNY) {&#10;        sem_wait(&amp;shm-&gt;shm_mutex);&#10;        shm-&gt;aktualna_pozicia_chodca.riadok = aktualny_r;&#10;        shm-&gt;aktualna_pozicia_chodca.stlpec = aktualny_s;&#10;        sem_post(&amp;shm-&gt;shm_mutex);&#10;&#10;        sem_post(&amp;shm-&gt;data_ready);&#10;        usleep(200000);&#10;    }&#10;&#10;    //chodec ide kym nieje v cieli alebo neprekroci pocet K&#10;    while ((aktualny_r != 0 || aktualny_s != 0) &amp;&amp; pocet_krok &lt; shm-&gt;K_max_kroky) {&#10;        if (shm-&gt;stav == SIM_STOP_REQUESTED) {&#10;            return;&#10;        }&#10;        int smer = vyber_smeru(shm) % 4;&#10;        int buduci_r = aktualny_r;&#10;        int buduci_s = aktualny_s;&#10;&#10;        //vypocet buducej pozicie s toroidnym efektom (BOD 3)&#10;        switch (smer) {&#10;            case 0: // HORE&#10;                buduci_r = (aktualny_r - 1 + shm-&gt;riadky) % shm-&gt;riadky;&#10;                break;&#10;            case 1: // DOLE&#10;                buduci_r = (aktualny_r + 1) % shm-&gt;riadky;&#10;                break;&#10;            case 2: // VLAVO&#10;                buduci_s = (aktualny_s - 1 + shm-&gt;stlpece) % shm-&gt;stlpece;&#10;                break;&#10;            case 3: // VPRAVO&#10;                buduci_s = (aktualny_s + 1) % shm-&gt;stlpece;&#10;                break;&#10;            default:&#10;                return;&#10;        }&#10;&#10;        // Kontrola prekážky: Ak na cieľovom políčku nie je stena, pohni sa&#10;        if (shm-&gt;svet[buduci_r][buduci_s] != PREKAZKA) {&#10;            aktualny_r = buduci_r;&#10;            aktualny_s = buduci_s;&#10;&#10;            sem_wait(&amp;shm-&gt;shm_mutex);&#10;            shm-&gt;aktualna_pozicia_chodca.riadok = aktualny_r;&#10;            shm-&gt;aktualna_pozicia_chodca.stlpec = aktualny_s;&#10;            sem_post(&amp;shm-&gt;shm_mutex);&#10;        }&#10;&#10;        pocet_krok++;&#10;&#10;        //ak je INTERAKTIVNY mod musi signalizovat klientovi&#10;        if (shm-&gt;mod == INTERAKTIVNY) {&#10;            sem_post(&amp;shm-&gt;data_ready);&#10;            usleep(100000);&#10;        }&#10;    }&#10;    // STATISTIKY&#10;    sem_wait(&amp;shm-&gt;shm_mutex);&#10;&#10;    // PRIČÍTAŠ K ŠTARTOVACÍM SÚRADNICIAM, nie k aktuálnym (ktoré sú 0,0)&#10;    shm-&gt;vysledky[start_r][start_s].avg_kroky += pocet_krok;&#10;&#10;    // Ak dosiel do ciela [0,0], zvysi pocitadlo uspechov&#10;    if (aktualny_r == 0 &amp;&amp; aktualny_s == 0) {&#10;        shm-&gt;vysledky[start_r][start_s].pravdepodobnost_dosiahnutia++;&#10;    }&#10;    sem_post(&amp;shm-&gt;shm_mutex);&#10;}&#10;&#10;/**&#10; * @brief Inicializuje herný svet pre server.&#10; * * Načíta svet zo súboru pri opätovnom spustení, alebo vygeneruje nový náhodný svet&#10; * s prekážkami a overí jeho priechodnosť pomocou BFS.&#10; * * @param shm Smerník na zdieľanú pamäť.&#10; * @return true ak bol svet úspešne inicializovaný, false pri chybe alebo požiadavke na stop.&#10; */&#10;bool inicializuj_svet_servera(ZdielaneData_t* shm) {&#10;    if (shm-&gt;opetovne_spustenie) {&#10;        if (!nacitaj_konfig_zo_suboru(shm)) {&#10;            printf(&quot;[SERVER] Chyba: nepodarilo sa nacitat subor %s\n&quot;, shm-&gt;nazov_suboru);&#10;            return false;&#10;        }&#10;        printf(&quot;[SERVER] Svet uspesne nacitany zo suboru\n&quot;);&#10;    } else {&#10;        int pokusy_generovania = 0;&#10;        do {&#10;            generuj_svet_s_prekazkami(shm, shm-&gt;pocet_prekazok);&#10;            pokusy_generovania++;&#10;&#10;            if (shm-&gt;stav == SIM_STOP_REQUESTED) return false;&#10;        } while (!je_svet_validny(shm));&#10;&#10;        printf(&quot;[SERVER] Svet vygenerovany na %d. pokus.\n&quot;, pokusy_generovania);&#10;    }&#10;    return true;&#10;}&#10;&#10;/**&#10; * @brief Vykoná kompletnú sumárnu simuláciu pre všetky políčka sveta.&#10; * * Pre každú replikáciu prejde všetky políčka mriežky. Ak políčko nie je prekážka,&#10; * spustí z neho simuláciu náhodnej chôdze. Špeciálne ošetruje cieľový bod [0,0].&#10; * * @param shm Smerník na zdieľanú pamäť.&#10; */&#10;void vykonaj_sumarnu_simulaciu(ZdielaneData_t* shm) {&#10;    // Reset výsledkov v zdieľanej pamäti pod mutexom&#10;    sem_wait(&amp;shm-&gt;shm_mutex);&#10;    for(int r = 0; r &lt; shm-&gt;riadky; r++) {&#10;        for(int s = 0; s &lt; shm-&gt;stlpece; s++) {&#10;            shm-&gt;vysledky[r][s].avg_kroky = 0;&#10;            shm-&gt;vysledky[r][s].pravdepodobnost_dosiahnutia = 0;&#10;        }&#10;    }&#10;    sem_post(&amp;shm-&gt;shm_mutex);&#10;&#10;    // Hlavný cyklus replikácií&#10;    for (int r_id = 0; r_id &lt; shm-&gt;total_replikacie; r_id++) {&#10;        if (shm-&gt;stav == SIM_STOP_REQUESTED) break;&#10;        shm-&gt;aktualne_replikacie = r_id;&#10;&#10;        for (int riadok = 0; riadok &lt; shm-&gt;riadky; riadok++) {&#10;            for (int stlpec = 0; stlpec &lt; shm-&gt;stlpece; stlpec++) {&#10;                if (shm-&gt;stav == SIM_STOP_REQUESTED) return;&#10;&#10;                // Bod [0,0] je cieľ - automaticky 100% úspešnosť, 0 krokov&#10;                if (riadok == 0 &amp;&amp; stlpec == 0) {&#10;                    if (r_id == 0) {&#10;                        sem_wait(&amp;shm-&gt;shm_mutex);&#10;                        shm-&gt;vysledky[riadok][stlpec].pravdepodobnost_dosiahnutia = shm-&gt;total_replikacie;&#10;                        shm-&gt;vysledky[riadok][stlpec].avg_kroky = 0;&#10;                        sem_post(&amp;shm-&gt;shm_mutex);&#10;                    }&#10;                    continue; // Simulácia chôdze pre cieľ sa nespúšťa&#10;                }&#10;&#10;                if (shm-&gt;svet[riadok][stlpec] != PREKAZKA) {&#10;                    simuluj_chodzu_z_policka(shm, riadok, stlpec);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Hlavná riadiaca logika servera.&#10; * * Zabezpečuje čakanie na klienta, inicializáciu simulácie, spustenie zvoleného&#10; * módu (interaktívny/sumárny) a finálne uloženie výsledkov.&#10; * * @param shm Smerník na zdieľanú pamäť.&#10; */&#10;//TODO mozno to treba upravit tak aby som si vybral umiestnenie chodza a ukazal cestu do ciela&#10;void spusti_server(ZdielaneData_t* shm) {&#10;    printf(&quot;[SERVER] Čakám na inicializáciu menu klientom...\n&quot;);&#10;&#10;    // Aktívne čakanie na štart z menu&#10;    while (shm-&gt;stav != SIM_INIT) {&#10;        if (shm-&gt;stav == SIM_STOP_REQUESTED) return;&#10;        usleep(100000);&#10;    }&#10;    srand(time(NULL));&#10;&#10;    // Príprava sveta (načítanie/generovanie)&#10;    if (!inicializuj_svet_servera(shm)) {&#10;        shm-&gt;stav = SIM_FINISHED;&#10;        sem_post(&amp;shm-&gt;data_ready);&#10;        return;&#10;    }&#10;&#10;    printf(&quot;[SERVER] Svet pripravený. Štartujem simuláciu...\n&quot;);&#10;    shm-&gt;stav = SIM_RUNNING;&#10;&#10;    if (shm-&gt;mod == INTERAKTIVNY) {&#10;        // Spustenie jednej trajektórie zo stredu mapy&#10;        int start_r = shm-&gt;riadky / 2;&#10;        int start_s = shm-&gt;stlpece / 2;&#10;        shm-&gt;aktualne_replikacie = 0;&#10;&#10;        simuluj_chodzu_z_policka(shm, start_r, start_s);&#10;        usleep(300000); // Krátka pauza na doznenie vizualizácie&#10;    } else {&#10;        // Hromadný výpočet pre všetky políčka&#10;        vykonaj_sumarnu_simulaciu(shm);&#10;    }&#10;&#10;    // Finálne uloženie dát a upratovanie stavu&#10;    if (shm-&gt;stav != SIM_STOP_REQUESTED) {&#10;        printf(&quot;[SERVER] Ukladám výsledky do súboru...\n&quot;);&#10;        uloz_vysledky_do_suboru(shm);&#10;    }&#10;&#10;    shm-&gt;stav = SIM_FINISHED;&#10;    sem_post(&amp;shm-&gt;data_ready); // Prebudenie klienta pre finálne zobrazenie&#10;    printf(&quot;[SERVER] Simulácia ukončená.\n&quot;);&#10;}" />
              <option name="updatedContent" value="#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;time.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;stdbool.h&gt;&#10;#include &quot;headers/ipc_shm.h&quot;&#10;&#10;/**&#10; * @brief Uloží výsledky simulácie a konfiguráciu sveta do súboru.&#10; *&#10; * Ak `shm-&gt;nazov_suboru` je prázdny reťazec, funkcia nič nerobí.&#10; * Do súboru uloží rozmery mapy, nastavenia replikácií a krokov, počet&#10; * prekážok, pravdepodobnosti pohybov, mapu sveta (0 = prázdne, 1 = prekážka)&#10; * a agregované výsledky pre každé políčko (priemerný počet krokov a&#10; * percento úspešnosti).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu výsledky a konfiguráciu.&#10; */&#10;void uloz_vysledky_do_suboru(ZdielaneData_t* shm) {&#10;    //ak nezadal nazov&#10;    if (shm-&gt;nazov_suboru[0] == '\0') {&#10;        return;&#10;    }&#10;&#10;    FILE * file = fopen(shm-&gt;nazov_suboru, &quot;w&quot;);&#10;    if (file == NULL) {&#10;        perror(&quot;Nepodarilo sa otvorit subor na zapis&quot;);&#10;        return;&#10;    }&#10;&#10;    //uloz zakladne parametre&#10;    fprintf(file, &quot;%d %d\n&quot;, shm-&gt;riadky, shm-&gt;stlpece);&#10;    fprintf(file, &quot;%d %d\n&quot;, shm-&gt;total_replikacie, shm-&gt;K_max_kroky);&#10;    fprintf(file, &quot;%d\n&quot;, shm-&gt;pocet_prekazok); // preistotu aj ked nacitavam tu ulozenu mapu&#10;    fprintf(file, &quot;%f %f %f %f \n&quot;, shm-&gt;pravdepodobnost[0], shm-&gt;pravdepodobnost[1], shm-&gt;pravdepodobnost[2], shm-&gt;pravdepodobnost[3]);&#10;&#10;    //ulozenie mapy sveta (0 = prazdne, 1 = prekazka)&#10;    for (int i = 0; i &lt; shm-&gt;riadky; i++) {&#10;        for (int j = 0; j &lt; shm-&gt;stlpece; j++) {&#10;            fprintf(file, &quot;%d &quot;, shm-&gt;svet[i][j]);&#10;        }&#10;        fprintf(file, &quot;\n&quot;);&#10;    }&#10;&#10;    //ulozenie vysledkov&#10;    fprintf(file, &quot;--- VYSLEDKY ---\n&quot;);&#10;    for (int i = 0; i &lt; shm-&gt;riadky; i++) {&#10;        for (int j = 0; j &lt; shm-&gt;stlpece; j++) {&#10;            double avg = (double)shm-&gt;vysledky[i][j].avg_kroky / shm-&gt;total_replikacie;&#10;            double pravdepodobnost = ((double)shm-&gt;vysledky[i][j].pravdepodobnost_dosiahnutia / shm-&gt;total_replikacie * 100);&#10;            fprintf(file, &quot;%.2f(%.0f%%) &quot;, avg, pravdepodobnost);&#10;        }&#10;        fprintf(file, &quot;\n&quot;);&#10;    }&#10;    fclose(file);&#10;    printf(&quot;[SERVER] Vysledky boli ulozene do suboru: %s\n&quot;, shm-&gt;nazov_suboru);&#10;}&#10;&#10;/**&#10; * @brief Načíta konfiguráciu a mapu sveta zo súboru do zdieľanej pamäte.&#10; *&#10; * Očakáva formát uložený funkciou `uloz_vysledky_do_suboru`. V prípade&#10; * chyby pri čítaní alebo parsovaní vráti false a zatvorí súbor.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru, kam sa načítajú hodnoty.&#10; * @return true ak bolo načítanie úspešné, inak false.&#10; */&#10;bool nacitaj_konfig_zo_suboru(ZdielaneData_t* shm) {&#10;    FILE* file = fopen(shm-&gt;nazov_suboru, &quot;r&quot;);&#10;    if (file == NULL) {&#10;        perror(&quot;Nepodarilo sa otvorit subor na citanie&quot;);&#10;        return false;&#10;    }&#10;&#10;    //nacitanie zakladnych parametrov (riadky, stlpce, replikacie, kroky)&#10;    if (fscanf(file, &quot;%d %d&quot;, &amp;shm-&gt;riadky, &amp;shm-&gt;stlpece) != 2) {&#10;        fclose(file);&#10;        return false;&#10;    }&#10;    if (fscanf(file, &quot;%d %d&quot;, &amp;shm-&gt;total_replikacie, &amp;shm-&gt;K_max_kroky) != 2) {&#10;        fclose(file);&#10;        return false;&#10;    }&#10;&#10;    //nacitanie hustoty prekazok aj ked ju pri nacitani nepouzivam&#10;    if (fscanf(file, &quot;%d&quot;, &amp;shm-&gt;pocet_prekazok) != 1) {&#10;        fclose(file);&#10;        return false;&#10;    }&#10;&#10;    //nacitanie pravdepodobnosti pohybu (pouzivam float docasne kvoli fscanf potom convert do double)&#10;    float p0, p1, p2, p3;&#10;    if (fscanf(file, &quot;%f %f %f %f&quot;, &amp;p0, &amp;p1, &amp;p2, &amp;p3) != 4) {&#10;        fclose(file);&#10;        return false;&#10;    }&#10;    shm-&gt;pravdepodobnost[0] = p0;&#10;    shm-&gt;pravdepodobnost[1] = p1;&#10;    shm-&gt;pravdepodobnost[2] = p2;&#10;    shm-&gt;pravdepodobnost[3] = p3;&#10;&#10;    //nacitanie mapy sveta (0 = prazdne, 1 = prekazka)&#10;    for (int i = 0; i &lt; shm-&gt;riadky; i++) {&#10;        for (int j = 0; j &lt; shm-&gt;stlpece; j++) {&#10;            int hodnota;&#10;            if (fscanf(file, &quot;%d&quot;, &amp;hodnota) != 1) {&#10;                fclose(file);&#10;                return false;&#10;            }&#10;            shm-&gt;svet[i][j] = hodnota;&#10;        }&#10;    }&#10;    //vysledky ma nezaujimaju pre novu simulacii takze zatvaram&#10;    fclose(file);&#10;    return true;&#10;}&#10;&#10;/**&#10; * @brief Overí, či je svet priechodný (všetky neprekážkové políčka dosiahnuteľné z [0,0]).&#10; *&#10; * Používa BFS na toroidnej mriežke (okraje sa &quot;zabalia&quot;). Porovná počet&#10; * navštívených políčok s počtom voľných políčok v mape.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu mapu a rozmery.&#10; * @return true ak sú všetky neprekážkové políčka dosiahnuteľné, inak false.&#10; */&#10;bool je_svet_validny(ZdielaneData_t* shm) {&#10;    int riadky = shm-&gt;riadky;&#10;    int stlpce = shm-&gt;stlpece;&#10;&#10;    //spocitanie kolko volnych policok vratane ciela v mape je&#10;    int celkovy_pocet = 0;&#10;    for (int riadok = 0; riadok &lt; riadky; riadok++) {&#10;        for (int stlpec = 0; stlpec &lt; stlpce; stlpec++) {&#10;            if (shm-&gt;svet[riadok][stlpec] != PREKAZKA) {&#10;                celkovy_pocet++;&#10;            }&#10;        }&#10;    }&#10;&#10;    //BFS priprava&#10;    bool navstivene[MAX_ROWS][MAX_COLS] = {false};&#10;    int front_r[MAX_ROWS * MAX_COLS];&#10;    int front_s[MAX_ROWS * MAX_COLS];&#10;    int zaciatok = 0;&#10;    int koniec = 0;&#10;&#10;    //start z [0,0]&#10;    front_r[koniec] = 0;&#10;    front_s[koniec] = 0;&#10;    koniec++;&#10;    navstivene[0][0] = true;&#10;    int dosiahnutelnych = 1;&#10;&#10;    //rozlievanie cez BFS&#10;    while (zaciatok &lt; koniec) {&#10;        int riadok = front_r[zaciatok];&#10;        int stlpec = front_s[zaciatok];  //oprava indexu po zaciatok++&#10;&#10;        zaciatok++;&#10;&#10;        int posun_riadok[] = {-1, 1, 0, 0};&#10;        int posun_stlpec[] = {0, 0, -1, 1};&#10;&#10;        for (int i = 0; i &lt; 4; i++) {&#10;            //toroidny sused&#10;            int novy_riadok = ((riadok + posun_riadok[i] + riadky) % riadky);&#10;            int novy_stlpec = ((stlpec + posun_stlpec[i] + stlpce) % stlpce);&#10;&#10;            if (shm-&gt;svet[novy_riadok][novy_stlpec] != PREKAZKA &amp;&amp; !navstivene[novy_riadok][novy_stlpec]) {&#10;                navstivene[novy_riadok][novy_stlpec] = true;&#10;                front_r[koniec] = novy_riadok;&#10;                front_s[koniec] = novy_stlpec;&#10;                koniec++;&#10;                dosiahnutelnych++;&#10;            }&#10;        }&#10;    }&#10;    //ak som sa dostal na vsetky volne policka mapa je v poriadku&#10;    return (dosiahnutelnych == celkovy_pocet);&#10;}&#10;&#10;/**&#10; * @brief Vyberie smer pohybu na základe nastavených pravdepodobností.&#10; *&#10; * Generuje náhodné číslo v [0,1) a vráti index smeru podľa kumulatívnych&#10; * pravdepodobností v poli `shm-&gt;pravdepodobnost`.&#10; * Indexy sú mapované takto: 0 = HORE, 1 = DOLE, 2 = VLAVO, 3 = VPRAVO.&#10; * Ako poistka vráti 3 (VPRAVO) pre prípad zaokrúhľovacích chýb.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu pole pravdepodobností.&#10; * @return Číslo v rozsahu 0..3 reprezentujúce smer.&#10; */&#10;int vyber_smeru(ZdielaneData_t* shm) {&#10;    double r = (double)rand() / RAND_MAX;&#10;    double kumulativna_suma = 0;&#10;&#10;    for (int i = 0; i &lt; 4; i++) {&#10;        kumulativna_suma += shm-&gt;pravdepodobnost[i];&#10;        if (r &lt;= kumulativna_suma) {&#10;            return i; //vrati 0(HORE) 1(DOLE) 2(Vlavo) 3(Vpravo)&#10;        }&#10;    }&#10;    return 3; // Poistka pre zaokrúhľovacie chyby (Vpravo)&#10;}&#10;&#10;/**&#10; * @brief Vygeneruje náhodný svet s prekážkami podľa percenta.&#10; *&#10; * Každé políčko (okrem cieľa [0,0] a stredu mapy) sa nastaví na prekážku&#10; * s pravdepodobnosťou `percento_prekazok` percent. Hodnoty sa ukladajú do&#10; * `shm-&gt;svet` (PRAZDNE alebo PREKAZKA).&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru obsahujúcu rozmery a mapu.&#10; * @param percento_prekazok Celé percento (0-100) šance, že políčko bude prekážka.&#10; */&#10;void generuj_svet_s_prekazkami(ZdielaneData_t* shm, int percento_prekazok) {&#10;    for (int riadok = 0; riadok &lt; shm-&gt;riadky; riadok++) {&#10;        for (int stlpec = 0; stlpec &lt; shm-&gt;stlpece; stlpec++) {&#10;&#10;            //ochrana aby ciel [0,0] nemohol byt prekazka&#10;            if (riadok == 0 &amp;&amp; stlpec == 0) {&#10;                shm-&gt;svet[riadok][stlpec] = PRAZDNE;&#10;                continue;&#10;            }&#10;&#10;            //vynechanie stred mriezky aby chodec nezacinal v stene&#10;            if (riadok == shm-&gt;riadky / 2 &amp;&amp; stlpec == shm-&gt;stlpece / 2) {&#10;                shm-&gt;svet[riadok][stlpec] = PRAZDNE;&#10;                continue;&#10;            }&#10;            //nahodne rozhodnutie ci na policku bude prekazka&#10;            if ((rand() % 100) &lt; percento_prekazok) {&#10;                shm-&gt;svet[riadok][stlpec] = PREKAZKA;&#10;            } else {&#10;                shm-&gt;svet[riadok][stlpec] = PRAZDNE;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Simuluje jedného chodca z daného štartovacieho políčka.&#10; *&#10; * Hlavný simulačný cyklus pohybuje chodcom, kontroluje kolízie s prekážkami&#10; * a v interaktívnom režime aktualizuje pozíciu cez semafory pre klienta.&#10; * Po skončení replikácie aktualizuje štatistiky (priemerné kroky a počet úspechov)&#10; * pre štartovacie políčko.&#10; *&#10; * @param shm Ukazovateľ na zdieľanú štruktúru s konfiguráciou a výsledkami.&#10; * @param start_r Počiatočný riadok chodca.&#10; * @param start_s Počiatočný stĺpec chodca.&#10; */&#10;void simuluj_chodzu_z_policka(ZdielaneData_t* shm, int start_r, int start_s) {&#10;    int aktualny_r = start_r;&#10;    int aktualny_s = start_s;&#10;    int pocet_krok = 0;&#10;&#10;    //zobrazenie startovacej pozicie chodcu&#10;    if (shm-&gt;mod == INTERAKTIVNY) {&#10;        sem_wait(&amp;shm-&gt;shm_mutex);&#10;        shm-&gt;aktualna_pozicia_chodca.riadok = aktualny_r;&#10;        shm-&gt;aktualna_pozicia_chodca.stlpec = aktualny_s;&#10;        sem_post(&amp;shm-&gt;shm_mutex);&#10;&#10;        sem_post(&amp;shm-&gt;data_ready);&#10;        usleep(200000);&#10;    }&#10;&#10;    //chodec ide kym nieje v cieli alebo neprekroci pocet K&#10;    while ((aktualny_r != 0 || aktualny_s != 0) &amp;&amp; pocet_krok &lt; shm-&gt;K_max_kroky) {&#10;        if (shm-&gt;stav == SIM_STOP_REQUESTED) {&#10;            return;&#10;        }&#10;        int smer = vyber_smeru(shm) % 4;&#10;        int buduci_r = aktualny_r;&#10;        int buduci_s = aktualny_s;&#10;&#10;        //vypocet buducej pozicie s toroidnym efektom (BOD 3)&#10;        switch (smer) {&#10;            case 0: // HORE&#10;                buduci_r = (aktualny_r - 1 + shm-&gt;riadky) % shm-&gt;riadky;&#10;                break;&#10;            case 1: // DOLE&#10;                buduci_r = (aktualny_r + 1) % shm-&gt;riadky;&#10;                break;&#10;            case 2: // VLAVO&#10;                buduci_s = (aktualny_s - 1 + shm-&gt;stlpece) % shm-&gt;stlpece;&#10;                break;&#10;            case 3: // VPRAVO&#10;                buduci_s = (aktualny_s + 1) % shm-&gt;stlpece;&#10;                break;&#10;            default:&#10;                return;&#10;        }&#10;&#10;        // Kontrola prekážky: Ak na cieľovom políčku nie je stena, pohni sa&#10;        if (shm-&gt;svet[buduci_r][buduci_s] != PREKAZKA) {&#10;            aktualny_r = buduci_r;&#10;            aktualny_s = buduci_s;&#10;&#10;            sem_wait(&amp;shm-&gt;shm_mutex);&#10;            shm-&gt;aktualna_pozicia_chodca.riadok = aktualny_r;&#10;            shm-&gt;aktualna_pozicia_chodca.stlpec = aktualny_s;&#10;            sem_post(&amp;shm-&gt;shm_mutex);&#10;        }&#10;&#10;        pocet_krok++;&#10;&#10;        //ak je INTERAKTIVNY mod musi signalizovat klientovi&#10;        if (shm-&gt;mod == INTERAKTIVNY) {&#10;            sem_post(&amp;shm-&gt;data_ready);&#10;            usleep(100000);&#10;        }&#10;    }&#10;    // STATISTIKY&#10;    sem_wait(&amp;shm-&gt;shm_mutex);&#10;&#10;    // PRIČÍTAŠ K ŠTARTOVACÍM SÚRADNICIAM, nie k aktuálnym (ktoré sú 0,0)&#10;    shm-&gt;vysledky[start_r][start_s].avg_kroky += pocet_krok;&#10;&#10;    // Ak dosiel do ciela [0,0], zvysi pocitadlo uspechov&#10;    if (aktualny_r == 0 &amp;&amp; aktualny_s == 0) {&#10;        shm-&gt;vysledky[start_r][start_s].pravdepodobnost_dosiahnutia++;&#10;    }&#10;    sem_post(&amp;shm-&gt;shm_mutex);&#10;}&#10;&#10;/**&#10; * @brief Inicializuje herný svet pre server.&#10; * * Načíta svet zo súboru pri opätovnom spustení, alebo vygeneruje nový náhodný svet&#10; * s prekážkami a overí jeho priechodnosť pomocou BFS.&#10; * * @param shm Smerník na zdieľanú pamäť.&#10; * @return true ak bol svet úspešne inicializovaný, false pri chybe alebo požiadavke na stop.&#10; */&#10;bool inicializuj_svet_servera(ZdielaneData_t* shm) {&#10;    if (shm-&gt;opetovne_spustenie) {&#10;        if (!nacitaj_konfig_zo_suboru(shm)) {&#10;            printf(&quot;[SERVER] Chyba: nepodarilo sa nacitat subor %s\n&quot;, shm-&gt;nazov_suboru);&#10;            return false;&#10;        }&#10;        printf(&quot;[SERVER] Svet uspesne nacitany zo suboru\n&quot;);&#10;    } else {&#10;        int pokusy_generovania = 0;&#10;        do {&#10;            generuj_svet_s_prekazkami(shm, shm-&gt;pocet_prekazok);&#10;            pokusy_generovania++;&#10;&#10;            if (shm-&gt;stav == SIM_STOP_REQUESTED) return false;&#10;        } while (!je_svet_validny(shm));&#10;&#10;        printf(&quot;[SERVER] Svet vygenerovany na %d. pokus.\n&quot;, pokusy_generovania);&#10;    }&#10;    return true;&#10;}&#10;&#10;/**&#10; * @brief Vykoná kompletnú sumárnu simuláciu pre všetky políčka sveta.&#10; * * Pre každú replikáciu prejde všetky políčka mriežky. Ak políčko nie je prekážka,&#10; * spustí z neho simuláciu náhodnej chôdze. Špeciálne ošetruje cieľový bod [0,0].&#10; * * @param shm Smerník na zdieľanú pamäť.&#10; */&#10;void vykonaj_sumarnu_simulaciu(ZdielaneData_t* shm) {&#10;    // Reset výsledkov v zdieľanej pamäti pod mutexom&#10;    sem_wait(&amp;shm-&gt;shm_mutex);&#10;    for(int r = 0; r &lt; shm-&gt;riadky; r++) {&#10;        for(int s = 0; s &lt; shm-&gt;stlpece; s++) {&#10;            shm-&gt;vysledky[r][s].avg_kroky = 0;&#10;            shm-&gt;vysledky[r][s].pravdepodobnost_dosiahnutia = 0;&#10;        }&#10;    }&#10;    sem_post(&amp;shm-&gt;shm_mutex);&#10;&#10;    // Hlavný cyklus replikácií&#10;    for (int r_id = 0; r_id &lt; shm-&gt;total_replikacie; r_id++) {&#10;        if (shm-&gt;stav == SIM_STOP_REQUESTED) break;&#10;        shm-&gt;aktualne_replikacie = r_id;&#10;&#10;        for (int riadok = 0; riadok &lt; shm-&gt;riadky; riadok++) {&#10;            for (int stlpec = 0; stlpec &lt; shm-&gt;stlpece; stlpec++) {&#10;                if (shm-&gt;stav == SIM_STOP_REQUESTED) return;&#10;&#10;                // Bod [0,0] je cieľ - automaticky 100% úspešnosť, 0 krokov&#10;                if (riadok == 0 &amp;&amp; stlpec == 0) {&#10;                    if (r_id == 0) {&#10;                        sem_wait(&amp;shm-&gt;shm_mutex);&#10;                        shm-&gt;vysledky[riadok][stlpec].pravdepodobnost_dosiahnutia = shm-&gt;total_replikacie;&#10;                        shm-&gt;vysledky[riadok][stlpec].avg_kroky = 0;&#10;                        sem_post(&amp;shm-&gt;shm_mutex);&#10;                    }&#10;                    continue; // Simulácia chôdze pre cieľ sa nespúšťa&#10;                }&#10;&#10;                if (shm-&gt;svet[riadok][stlpec] != PREKAZKA) {&#10;                    simuluj_chodzu_z_policka(shm, riadok, stlpec);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * @brief Hlavná riadiaca logika servera.&#10; * * Zabezpečuje čakanie na klienta, inicializáciu simulácie, spustenie zvoleného&#10; * módu (interaktívny/sumárny) a finálne uloženie výsledkov.&#10; * * @param shm Smerník na zdieľanú pamäť.&#10; */&#10;//TODO mozno to treba upravit tak aby som si vybral umiestnenie chodza a ukazal cestu do ciela&#10;void spusti_server(ZdielaneData_t* shm) {&#10;    printf(&quot;[SERVER] Čakám na inicializáciu menu klientom...\n&quot;);&#10;&#10;    // Aktívne čakanie na štart z menu&#10;    while (shm-&gt;stav != SIM_INIT) {&#10;        if (shm-&gt;stav == SIM_STOP_REQUESTED) return;&#10;        usleep(100000);&#10;    }&#10;    srand(time(NULL));&#10;&#10;    // Príprava sveta (načítanie/generovanie)&#10;    if (!inicializuj_svet_servera(shm)) {&#10;        shm-&gt;stav = SIM_FINISHED;&#10;        sem_post(&amp;shm-&gt;data_ready);&#10;        return;&#10;    }&#10;&#10;    printf(&quot;[SERVER] Svet pripravený. Štartujem simuláciu...\n&quot;);&#10;    shm-&gt;stav = SIM_RUNNING;&#10;&#10;    if (shm-&gt;mod == INTERAKTIVNY) {&#10;        // Spustenie jednej trajektórie zo stredu mapy&#10;        int start_r = shm-&gt;riadky / 2;&#10;        int start_s = shm-&gt;stlpece / 2;&#10;        shm-&gt;aktualne_replikacie = 0;&#10;&#10;        simuluj_chodzu_z_policka(shm, start_r, start_s);&#10;        usleep(300000); // Krátka pauza na doznenie vizualizácie&#10;    } else {&#10;        // Hromadný výpočet pre všetky políčka&#10;        vykonaj_sumarnu_simulaciu(shm);&#10;    }&#10;&#10;    // Finálne uloženie dát a upratovanie stavu&#10;    if (shm-&gt;stav != SIM_STOP_REQUESTED) {&#10;        printf(&quot;[SERVER] Ukladám výsledky do súboru...\n&quot;);&#10;        uloz_vysledky_do_suboru(shm);&#10;    }&#10;&#10;    shm-&gt;stav = SIM_FINISHED;&#10;    sem_post(&amp;shm-&gt;data_ready); // Prebudenie klienta pre finálne zobrazenie&#10;    printf(&quot;[SERVER] Simulácia ukončená.\n&quot;);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>